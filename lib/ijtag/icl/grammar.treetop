module IJTAG
  module ICL
    grammar Grammar
      rule icl_source
        iclSource_items+ {
          def to_ast
            n :icl, *elements.map{ |e| e.to_ast if e.respond_to?(:to_ast) }.compact
          end
        }
      end

      rule iclSource_items
        S / ml_comment / sl_comment / nameSpace_def / useNameSpace_def / module_def
      end

      ####################################################
      # TOP LEVEL NODES
      ####################################################

      rule ml_comment
        "/*" (!end_of_comment .)* end_of_comment s
      end

      rule end_of_comment
        "*/"
      end

      rule sl_comment
        "//" (!N .)* s
      end

      rule nameSpace_def
        "NameSpace" s namespace_name? s ";" s
      end

      rule useNameSpace_def
        "UseNameSpace" s name:namespace_name? s ";" s {
          def to_ast
            n1 :useNameSpace_def, name.to_ast
          end
        }
      end

      rule module_def
        "Module" S name:module_name S "{" s items:module_item* s "}" s {
          def to_ast
            n :module_def, name.to_ast, *items.elements.map{ |e| e.to_ast }
          end
        }
      end

      rule module_item
        useNameSpace_def /
        port_def /
        instance_def /
        scanRegister_def /
        dataRegister_def /
        logicSignal_def /
        scanMux_def /
        dataMux_def /
        clockMux_def /
        oneHotDataGroup_def /
        oneHotScanGroup_def /
        scanInterface_def /
        accessLink_def /
        alias_def /
        enum_def /
        parameter_def /
        localParameter_def /
        attribute_def
      end

      rule port_def
        scanInPort_def /
        scanOutPort_def /
        shiftEnPort_def /
        captureEnPort_def /
        updateEnPort_def /
        dataInPort_def /
        dataOutPort_def /
        toShiftEnPort_def /
        toUpdateEnPort_def /
        toCaptureEnPort_def /
        selectPort_def /
        toSelectPort_def /
        resetPort_def /
        toResetPort_def /
        tmsPort_def /
        toTmsPort_def /
        tckPort_def /
        toTckPort_def /
        clockPort_def /
        toClockPort_def /
        trstPort_def /
        toTrstPort_def /
        toIRSelectPort_def /
        addressPort_def /
        writeEnPort_def /
        readEnPort_def
      end

      ####################################################
      # INTERMEDIATE NODES
      ####################################################

      rule scanInPort_def
        'ScanInPort' S name:scanInPort_name s (';' / ('{' s attrs:attribute_def* s '}')) s {
          def to_ast
            n :scanInPort_def, name.to_ast, *attrs.elements.map{ |e| e.to_ast }
          end
        }
      end

      rule scanOutPort_def
        'ScanOutPort' S name:scanOutPort_name s (';' / ('{' s items:scanOutPort_item* s '}')) s {
          def to_ast
            n :scanOutPort_def, name.to_ast, *items.elements.map{ |e| e.to_ast }
          end
        }
      end

      rule scanOutPort_item 
        attribute_def / scanOutPort_source / scanOutPort_enable
      end

      rule scanOutPort_source
        'Source' S signal:concat_scan_signal s ';' s {
          def to_ast
            n :scanOutPort_source, signal.to_ast
          end
        }
      end

      rule scanOutPort_enable
        'Enable' S signal:data_signal s ';' s {
          def to_ast
            n :scanOutPort_enable, signal.to_ast
          end
        }
      end

      rule shiftEnPort_def
        'ShiftEnPort' S name:shiftEnPort_name s (';' / ('{' s attrs:attribute_def* s '}')) s {
          def to_ast
            n :shiftEnPort_def, name.to_ast, *attrs.elements.map{ |e| e.to_ast }
          end
        }
      end

      rule captureEnPort_def
        'CaptureEnPort' S name:captureEnPort_name s (';' / ('{' s attrs:attribute_def* s '}')) s {
          def to_ast
            n :captureEnPort_def, name.to_ast, *attrs.elements.map{ |e| e.to_ast }
          end
        }
      end

      rule updateEnPort_def
        'UpdateEnPort' S name:updateEnPort_name s (';' / ('{' s attrs:attribute_def* s '}')) s {
          def to_ast
            n :updateEnPort_def, name.to_ast, *attrs.elements.map{ |e| e.to_ast }
          end
        }
      end

      rule dataInPort_def
        'DataInPort' S name:dataInPort_name s (';' / ('{' s items:dataInPort_item*  s '}')) s {
          def to_ast
            n :dataInPort_def, name.to_ast, *items.elements.map{ |e| e.to_ast }
          end
        }
      end
     
      rule dataInPort_item
        attribute_def /
        dataInPort_refEnum /
        dataInPort_defaultLoadValue
      end

      rule dataInPort_refEnum
        'RefEnum' s name:enum_name s ';' s {
          def to_ast
            n :dataInPort_refEnum, name.to_ast
          end
        }
      end

      rule dataInPort_defaultLoadValue
        'DefaultLoadValue' S val:(concat_number / enum_symbol) s ';' s {
          def to_ast
            n :dataInPort_defaultLoadValue, val.to_ast
          end
        }
      end

      rule dataOutPort_def
        'DataOutPort' S name:dataOutPort_name s (';' / ('{' s items:dataOutPort_item*  s '}')) s {
          def to_ast
            n :dataOutPort_def, name.to_ast, *items.elements.map{ |e| e.to_ast }
          end
        }
      end

      rule dataOutPort_item
        attribute_def /
        dataOutPort_source /
        dataOutPort_enable /
        dataOutPort_refEnum
      end

      rule dataOutPort_source
        'Source' S signal:concat_data_signal s ';' s {
          def to_ast
            n :dataOutPort_source, signal.to_ast
          end
        }
      end

      rule dataOutPort_enable
        'Enable' S signal:data_signal s ';' s {
          def to_ast
            n :dataOutPort_enable, signal.to_ast
          end
        }
      end

      rule dataOutPort_refEnum
        'RefEnum' S name:enum_name s ';' s {
          def to_ast
            n :dataOutPort_refEnum, name.to_ast
          end
        }
      end

      rule toShiftEnPort_def
        'ToShiftEnPort' S name:toShiftEnPort_name s (';' / ('{' s items:toShiftEnPort_items* s '}')) s {
          def to_ast
            n :toShiftEnPort_def, name.to_ast, *items.elements.map{ |e| e.to_ast }
          end
        }
      end

      rule toShiftEnPort_items
        attribute_def /
        toShiftEnPort_source
      end

      rule toShiftEnPort_source
        'Source' S signal:concat_shiftEn_signal s ';' s {
          def to_ast
            n :toShiftEnPort_source, signal.to_ast
          end
        }
      end

      rule toCaptureEnPort_def
        'ToCaptureEnPort' S name:toCaptureEnPort_name s (';' / ('{' s items:toCaptureEnPort_items* s '}')) s {
          def to_ast
            n :toCaptureEnPort_def, name.to_ast, *items.elements.map{ |e| e.to_ast }
          end
        }
      end

      rule toCaptureEnPort_items
        attribute_def /
        toCaptureEnPort_source
      end

      rule toCaptureEnPort_source
        'Source' S signal:captureEn_signal s ';' s {
          def to_ast
            n :toCaptureEnPort_source, signal.to_ast
          end
        }
      end

      rule toUpdateEnPort_def
        'ToUpdateEnPort' S name:toUpdateEnPort_name s (';' / ('{' s items:toUpdateEnPort_items* s '}')) s {
          def to_ast
            n :toUpdateEnPort_def, name.to_ast, *items.elements.map{ |e| e.to_ast }
          end
        }
      end 

      rule toUpdateEnPort_items
        attribute_def / toUpdateEnPort_source
      end

      rule toUpdateEnPort_source
        'Source' S signal:updateEn_signal s ';' s {
          def to_ast
            n :toUpdateEnPort_source, signal.to_ast
          end
        }
      end

      rule selectPort_def
        'SelectPort' S name:selectPort_name s (';' / ('{' s attrs:attribute_def* s '}')) s {
          def to_ast
            n :selectPort_def, name.to_ast, *attrs.elements.map{ |e| e.to_ast }
          end
        }
      end

      rule toSelectPort_def
        'ToSelectPort' S name:toSelectPort_name s (';' / ('{' s items:toSelectPort_item+ s '}')) s {
          def to_ast
            n :toSelectPort_def, name.to_ast, *items.elements.map{ |e| e.to_ast }
          end
        }
      end

      rule toSelectPort_item
        attribute_def / toSelectPort_source
      end

      rule toSelectPort_source
        'Source' S signal:concat_data_signal s ';' s {
          def to_ast
            n :toSelectPort_source, signal.to_ast
          end
        }
      end

      rule resetPort_def
        'ResetPort' S name:resetPort_name s (';' / ('{' s items:resetPort_item* s '}')) s {
          def to_ast
            n :resetPort_def, name.to_ast, *items.elements.map{ |e| e.to_ast }
          end
        }
      end

      ####################################################
      # TERMINAL NODES
      ####################################################

      rule resetPort_name
        port_name {
          def to_ast
            n1 :resetPort_name, text_value
          end
        }
      end

      rule toSelectPort_name
        port_name {
          def to_ast
            n1 :toSelectPort_name, text_value
          end
        }
      end

      rule selectPort_name
        port_name {
          def to_ast
            n1 :selectPort_name, text_value
          end
        }
      end

      rule toUpdateEnPort_name
        port_name {
          def to_ast
            n1 :toUpdateEnPort_name, text_value
          end
        }
      end

      rule toCaptureEnPort_name
        port_name {
          def to_ast
            n1 :toCaptureEnPort_name, text_value
          end
        }
      end
      
      rule toShiftEnPort_name
        port_name {
          def to_ast
            n1 :toShiftEnPort_name, text_value
          end
        }
      end

      rule dataOutPort_name
        port_name {
          def to_ast
            n1 :dataOutPort_name, text_value
          end
        }
      end

      rule dataInPort_name
        port_name {
          def to_ast
            n1 :dataInPort_name, text_value
          end
        }
      end

      rule updateEnPort_name
        port_name {
          def to_ast
            n1 :updateEnPort_name, text_value
          end
        }
      end

      rule captureEnPort_name
        port_name {
          def to_ast
            n1 :captureEnPort_name, text_value
          end
        }
      end

      rule shiftEnPort_name
        port_name {
          def to_ast
            n1 :shiftEnPort_name, text_value
          end
        }
      end

      rule scanInPort_name
        port_name {
          def to_ast
            n1 :scanInPort_name, text_value
          end
        }
      end

      rule scanOutPort_name
        port_name {
          def to_ast
            n1 :scanOutPort_name, text_value
          end
        }
      end

      rule hier_port
        (instance_name ".")+ port_name {
          def to_ast
            n1 :hier_port, text_value
          end
        }
      end

      rule port_name
        SCALAR_ID / vector_id { 
          def to_ast
            n1 :port_name, text_value
          end
        }
      end

      rule register_name
        SCALAR_ID / vector_id { 
          def to_ast
            n1 :register_name, text_value
          end
        }
      end

      rule instance_name
        SCALAR_ID {
          def to_ast
            n1 :instance_name, text_value
          end
        }
      end

      rule namespace_name
        SCALAR_ID {
          def to_ast
            n1 :namespace_name, text_value
          end
        }
      end

      rule module_name
        SCALAR_ID {
          def to_ast
            n1 :module_name, text_value
          end
        }
      end

      rule reg_port_signal_id
        SCALAR_ID / vector_id { 
          def to_ast
            n1 :reg_port_signal_id, text_value
          end
        }
      end

      rule signal
        number / reg_port_signal_id / hier_port { 
          def to_ast
            n1 :signal, text_value
          end
        }
      end

      rule reset_signal
        "~"? signal { 
          def to_ast
            n1 :reset_signal, text_value
          end
        }
      end

      rule scan_signal
        "~"? signal { 
          def to_ast
            n1 :scan_signal, text_value
          end
        }
      end
      
      rule data_signal
        "~"? signal { 
          def to_ast
            n1 :data_signal, text_value
          end
        }
      end

      rule clock_signal
        "~"? signal { 
          def to_ast
            n1 :clock_signal, text_value
          end
        }
      end

      rule tck_signal
        signal { 
          def to_ast
            n1 :tck_signal, text_value
          end
        }
      end

      rule tms_signal
        signal { 
          def to_ast
            n1 :tms_signal, text_value
          end
        }
      end

      rule trst_signal
        signal { 
          def to_ast
            n1 :trst_signal, text_value
          end
        }
      end

      rule shiftEn_signal
        signal { 
          def to_ast
            n1 :signalEn_signal, text_value
          end
        }
      end

      rule captureEn_signal
        signal { 
          def to_ast
            n1 :captureEn_signal, text_value
          end
        }
      end

      rule updateEn_signal
        signal { 
          def to_ast
            n1 :updateEn_signal, text_value
          end
        }
      end

      rule concat_reset_signal
        (reset_signal / data_signal) ("," reset_signal / data_signal)* { 
          def to_ast
            n1 :concat_reset_signal, text_value
          end
        }
      end

      rule concat_scan_signal
        (scan_signal / data_signal) ("," scan_signal / data_signal)* { 
          def to_ast
            n1 :concat_scan_signal, text_value
          end
        }
      end

      rule concat_data_signal
        (data_signal) ("," data_signal)* { 
          def to_ast
            n1 :concat_data_signal, text_value
          end
        }
      end

      rule concat_clock_signal
        (clock_signal / data_signal) ("," clock_signal / data_signal)* { 
          def to_ast
            n1 :concat_clock_signal, text_value
          end
        }
      end

      rule concat_tck_signal
        (tck_signal / data_signal) ("," tck_signal / data_signal)* { 
          def to_ast
            n1 :concat_tck_signal, text_value
          end
        }
      end

      rule concat_shiftEn_signal
        (shiftEn_signal / data_signal) ("," shiftEn_signal / data_signal)* { 
          def to_ast
            n1 :concat_shiftEn_signal, text_value
          end
        }
      end

      rule concat_captureEn_signal
        (captureEn_signal / data_signal) ("," captureEn_signal / data_signal)* { 
          def to_ast
            n1 :concat_captureEn_signal, text_value
          end
        }
      end

      rule concat_tms_signal
        (tms_signal / data_signal) ("," tms_signal / data_signal)* { 
          def to_ast
            n1 :concat_tms_signal, text_value
          end
        }
      end

      rule concat_trst_signal
        (trst_signal / data_signal) ("," trst_signal / data_signal)* { 
          def to_ast
            n1 :concat_trst_signal, text_value
          end
        }
      end

      ####################################################
      # VALUE FORMATS
      ####################################################

      rule SCALAR_ID
        [a-zA-Z] ([a-zA-Z_] / DEC_DIGIT)*
      end

      rule pos_int
        "0" / "1" / POS_INT
      end

      rule POS_INT
        DEC_DIGIT ('_' / DEC_DIGIT)*
      end

      rule size
        pos_int / '$' SCALAR_ID
      end

      rule UNKNOWN_DIGIT
        'X' / 'x'
      end

      rule DEC_DIGIT
        [0-9]
      end

      rule BIN_DIGIT
        [0-1] / UNKNOWN_DIGIT
      end

      rule HEX_DIGIT
        [0-9a-fA-F] / UNKNOWN_DIGIT
      end

      rule DEC_BASE
        "'" ('d' / 'D') (" " / "\t")*
      end

      rule BIN_BASE
        "'" ('b' / 'B') (" " / "\t")*
      end

      rule HEX_BASE
        "'" ('h' / 'H') (" " / "\t")*
      end

      rule UNSIZED_DEC_NUMBER
        DEC_BASE POS_INT
      end

      rule UNSIZED_BIN_NUMBER
        BIN_BASE BIN_DIGIT ("_" / BIN_DIGIT)*
      end

      rule UNSIZED_HEX_NUMBER
        HEX_BASE HEX_DIGIT ("_" / HEX_DIGIT)*
      end

      rule sized_dec_number
        size UNSIZED_DEC_NUMBER
      end

      rule sized_bin_number
        size UNSIZED_BIN_NUMBER
      end

      rule sized_hex_number
        size UNSIZED_HEX_NUMBER
      end

      rule vector_id
        SCALAR_ID "[" (index / range) "]"
      end

      rule index
        integer_expr
      end

      rule range
        index ":" index
      end

      rule number
        unsized_number / sized_number / integer_expr
      end

      rule integer_expr
        integer_expr_lvl1
      end

      rule integer_expr_lvl1
        integer_expr_lvl2 (("+" / "-") integer_expr_lvl1)?
      end

      rule integer_expr_lvl2
        integer_expr_arg (("*" / "/" / "%") integer_expr_lvl2)?
      end

      rule integer_expr_paren
        "(" integer_expr ")"
      end

      rule integer_expr_arg
        integer_expr_paren / pos_int / parameter_ref
      end

      rule parameter_ref
        "$" SCALAR_ID
      end

      rule unsized_number
        pos_int / UNSIZED_DEC_NUMBER / UNSIZED_BIN_NUMBER / UNSIZED_HEX_NUMBER
      end

      rule sized_number
        sized_dec_number / sized_bin_number / sized_hex_number
      end

      rule concat_number
        "~"? number ("," "~"? number)*
      end

      rule concat_number_list
        concat_number ("|" concat_number)*
      end

      ####################################################
      # HELPERS
      ####################################################

      # Optional space, including new lines and comments
      rule s
        (" " / "\t" / N / sl_comment / ml_comment)*
      end

      # Required space, including new lines and comments
      rule S
        (" " / "\t" / N / sl_comment / ml_comment)+
      end

      # Optional end of line
      rule n
        "\r"? "\n"?
      end

      # Required end of line
      rule N
        "\r"? "\n"
      end
    end
  end
end
