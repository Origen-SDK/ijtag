# Autogenerated from a Treetop grammar. Edits may be lost.


module IJTAG
  module ICL
    module Grammar
      include Treetop::Runtime

      def root
        @root ||= :icl_source
      end

      module IclSource0
        def to_ast
          n :icl_source, *elements.map{ |e| e.to_ast if e.respond_to?(:to_ast) }.compact, input: input, interval: interval, file: file
        end
      end

      def _nt_icl_source
        start_index = index
        if node_cache[:icl_source].has_key?(index)
          cached = node_cache[:icl_source][index]
          if cached
            node_cache[:icl_source][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          r1 = _nt_iclSource_items
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(IclSource0)
        end

        node_cache[:icl_source][start_index] = r0

        r0
      end

      def _nt_iclSource_items
        start_index = index
        if node_cache[:iclSource_items].has_key?(index)
          cached = node_cache[:iclSource_items][index]
          if cached
            node_cache[:iclSource_items][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_S
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_ml_comment
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_sl_comment
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              r4 = _nt_include_def
              if r4
                r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
                r0 = r4
              else
                r5 = _nt_nameSpace_def
                if r5
                  r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                  r0 = r5
                else
                  r6 = _nt_useNameSpace_def
                  if r6
                    r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                    r0 = r6
                  else
                    r7 = _nt_module_def
                    if r7
                      r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                      r0 = r7
                    else
                      @index = i0
                      r0 = nil
                    end
                  end
                end
              end
            end
          end
        end

        node_cache[:iclSource_items][start_index] = r0

        r0
      end

      module MlComment0
      end

      module MlComment1
        def end_of_comment
          elements[2]
        end

        def s
          elements[3]
        end
      end

      def _nt_ml_comment
        start_index = index
        if node_cache[:ml_comment].has_key?(index)
          cached = node_cache[:ml_comment][index]
          if cached
            node_cache[:ml_comment][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?("/*", false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('"/*"')
          r1 = nil
        end
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            i4 = index
            r5 = _nt_end_of_comment
            if r5
              @index = i4
              r4 = nil
            else
              @index = i4
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s3 << r4
            if r4
              if index < input_length
                r6 = true
                @index += 1
              else
                terminal_parse_failure("any character")
                r6 = nil
              end
              s3 << r6
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(MlComment0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
          if r2
            r7 = _nt_end_of_comment
            s0 << r7
            if r7
              r8 = _nt_s
              s0 << r8
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(MlComment1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:ml_comment][start_index] = r0

        r0
      end

      def _nt_end_of_comment
        start_index = index
        if node_cache[:end_of_comment].has_key?(index)
          cached = node_cache[:end_of_comment][index]
          if cached
            node_cache[:end_of_comment][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?("*/", false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('"*/"')
          r0 = nil
        end

        node_cache[:end_of_comment][start_index] = r0

        r0
      end

      module SlComment0
      end

      module SlComment1
        def s
          elements[2]
        end
      end

      def _nt_sl_comment
        start_index = index
        if node_cache[:sl_comment].has_key?(index)
          cached = node_cache[:sl_comment][index]
          if cached
            node_cache[:sl_comment][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?("//", false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('"//"')
          r1 = nil
        end
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            i4 = index
            r5 = _nt_N
            if r5
              @index = i4
              r4 = nil
            else
              @index = i4
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s3 << r4
            if r4
              if index < input_length
                r6 = true
                @index += 1
              else
                terminal_parse_failure("any character")
                r6 = nil
              end
              s3 << r6
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(SlComment0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
          if r2
            r7 = _nt_s
            s0 << r7
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SlComment1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:sl_comment][start_index] = r0

        r0
      end

      module IncludeDef0
        def S
          elements[1]
        end

        def path
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module IncludeDef1
        def to_ast
          n :include, path.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_include_def
        start_index = index
        if node_cache[:include_def].has_key?(index)
          cached = node_cache[:include_def][index]
          if cached
            node_cache[:include_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?("#include", false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('"#include"')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_STRING
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(";", false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('";"')
                  r6 = nil
                end
                if r6
                  r5 = r6
                else
                  r5 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r5
                if r5
                  r7 = _nt_s
                  s0 << r7
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(IncludeDef0)
          r0.extend(IncludeDef1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:include_def][start_index] = r0

        r0
      end

      module NameSpaceDef0
        def s1
          elements[1]
        end

        def name
          elements[2]
        end

        def s2
          elements[3]
        end

        def s3
          elements[5]
        end
      end

      module NameSpaceDef1
        def to_ast
          n :nameSpace_def, name.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_nameSpace_def
        start_index = index
        if node_cache[:nameSpace_def].has_key?(index)
          cached = node_cache[:nameSpace_def][index]
          if cached
            node_cache[:nameSpace_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?("NameSpace", false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('"NameSpace"')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            r4 = _nt_namespace_name
            if r4
              r3 = r4
            else
              r3 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r3
            if r3
              r5 = _nt_s
              s0 << r5
              if r5
                if (match_len = has_terminal?(";", false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('";"')
                  r6 = nil
                end
                s0 << r6
                if r6
                  r7 = _nt_s
                  s0 << r7
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(NameSpaceDef0)
          r0.extend(NameSpaceDef1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:nameSpace_def][start_index] = r0

        r0
      end

      module UseNameSpaceDef0
        def s1
          elements[1]
        end

        def name
          elements[2]
        end

        def s2
          elements[3]
        end

        def s3
          elements[5]
        end
      end

      module UseNameSpaceDef1
        def to_ast
          n :useNameSpace_def, name.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_useNameSpace_def
        start_index = index
        if node_cache[:useNameSpace_def].has_key?(index)
          cached = node_cache[:useNameSpace_def][index]
          if cached
            node_cache[:useNameSpace_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?("UseNameSpace", false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('"UseNameSpace"')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            r4 = _nt_namespace_name
            if r4
              r3 = r4
            else
              r3 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r3
            if r3
              r5 = _nt_s
              s0 << r5
              if r5
                if (match_len = has_terminal?(";", false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('";"')
                  r6 = nil
                end
                s0 << r6
                if r6
                  r7 = _nt_s
                  s0 << r7
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(UseNameSpaceDef0)
          r0.extend(UseNameSpaceDef1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:useNameSpace_def][start_index] = r0

        r0
      end

      module ModuleDef0
        def S1
          elements[1]
        end

        def name
          elements[2]
        end

        def S2
          elements[3]
        end

        def s1
          elements[5]
        end

        def items
          elements[6]
        end

        def s2
          elements[7]
        end

        def s3
          elements[9]
        end
      end

      module ModuleDef1
        def to_ast
          if respond_to?(:items)
            n :module_def, name.to_ast, *items.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :module_def, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_module_def
        start_index = index
        if node_cache[:module_def].has_key?(index)
          cached = node_cache[:module_def][index]
          if cached
            node_cache[:module_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?("Module", false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('"Module"')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_module_name
            s0 << r3
            if r3
              r4 = _nt_S
              s0 << r4
              if r4
                if (match_len = has_terminal?("{", false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('"{"')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                  if r6
                    s7, i7 = [], index
                    loop do
                      r8 = _nt_module_item
                      if r8
                        s7 << r8
                      else
                        break
                      end
                    end
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    s0 << r7
                    if r7
                      r9 = _nt_s
                      s0 << r9
                      if r9
                        if (match_len = has_terminal?("}", false, index))
                          r10 = true
                          @index += match_len
                        else
                          terminal_parse_failure('"}"')
                          r10 = nil
                        end
                        s0 << r10
                        if r10
                          r11 = _nt_s
                          s0 << r11
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ModuleDef0)
          r0.extend(ModuleDef1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:module_def][start_index] = r0

        r0
      end

      def _nt_module_item
        start_index = index
        if node_cache[:module_item].has_key?(index)
          cached = node_cache[:module_item][index]
          if cached
            node_cache[:module_item][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_useNameSpace_def
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_port_def
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_instance_def
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              r4 = _nt_scanRegister_def
              if r4
                r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
                r0 = r4
              else
                r5 = _nt_dataRegister_def
                if r5
                  r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                  r0 = r5
                else
                  r6 = _nt_logicSignal_def
                  if r6
                    r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                    r0 = r6
                  else
                    r7 = _nt_scanMux_def
                    if r7
                      r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                      r0 = r7
                    else
                      r8 = _nt_dataMux_def
                      if r8
                        r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
                        r0 = r8
                      else
                        r9 = _nt_clockMux_def
                        if r9
                          r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
                          r0 = r9
                        else
                          r10 = _nt_oneHotDataGroup_def
                          if r10
                            r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                            r0 = r10
                          else
                            r11 = _nt_oneHotScanGroup_def
                            if r11
                              r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
                              r0 = r11
                            else
                              r12 = _nt_scanInterface_def
                              if r12
                                r12 = SyntaxNode.new(input, (index-1)...index) if r12 == true
                                r0 = r12
                              else
                                r13 = _nt_accessLink_def
                                if r13
                                  r13 = SyntaxNode.new(input, (index-1)...index) if r13 == true
                                  r0 = r13
                                else
                                  r14 = _nt_alias_def
                                  if r14
                                    r14 = SyntaxNode.new(input, (index-1)...index) if r14 == true
                                    r0 = r14
                                  else
                                    r15 = _nt_enum_def
                                    if r15
                                      r15 = SyntaxNode.new(input, (index-1)...index) if r15 == true
                                      r0 = r15
                                    else
                                      r16 = _nt_parameter_def
                                      if r16
                                        r16 = SyntaxNode.new(input, (index-1)...index) if r16 == true
                                        r0 = r16
                                      else
                                        r17 = _nt_localParameter_def
                                        if r17
                                          r17 = SyntaxNode.new(input, (index-1)...index) if r17 == true
                                          r0 = r17
                                        else
                                          r18 = _nt_attribute_def
                                          if r18
                                            r18 = SyntaxNode.new(input, (index-1)...index) if r18 == true
                                            r0 = r18
                                          else
                                            @index = i0
                                            r0 = nil
                                          end
                                        end
                                      end
                                    end
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end

        node_cache[:module_item][start_index] = r0

        r0
      end

      def _nt_port_def
        start_index = index
        if node_cache[:port_def].has_key?(index)
          cached = node_cache[:port_def][index]
          if cached
            node_cache[:port_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_scanInPort_def
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_scanOutPort_def
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_shiftEnPort_def
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              r4 = _nt_captureEnPort_def
              if r4
                r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
                r0 = r4
              else
                r5 = _nt_updateEnPort_def
                if r5
                  r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                  r0 = r5
                else
                  r6 = _nt_dataInPort_def
                  if r6
                    r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                    r0 = r6
                  else
                    r7 = _nt_dataOutPort_def
                    if r7
                      r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                      r0 = r7
                    else
                      r8 = _nt_toShiftEnPort_def
                      if r8
                        r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
                        r0 = r8
                      else
                        r9 = _nt_toUpdateEnPort_def
                        if r9
                          r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
                          r0 = r9
                        else
                          r10 = _nt_toCaptureEnPort_def
                          if r10
                            r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                            r0 = r10
                          else
                            r11 = _nt_selectPort_def
                            if r11
                              r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
                              r0 = r11
                            else
                              r12 = _nt_toSelectPort_def
                              if r12
                                r12 = SyntaxNode.new(input, (index-1)...index) if r12 == true
                                r0 = r12
                              else
                                r13 = _nt_resetPort_def
                                if r13
                                  r13 = SyntaxNode.new(input, (index-1)...index) if r13 == true
                                  r0 = r13
                                else
                                  r14 = _nt_toResetPort_def
                                  if r14
                                    r14 = SyntaxNode.new(input, (index-1)...index) if r14 == true
                                    r0 = r14
                                  else
                                    r15 = _nt_tmsPort_def
                                    if r15
                                      r15 = SyntaxNode.new(input, (index-1)...index) if r15 == true
                                      r0 = r15
                                    else
                                      r16 = _nt_toTmsPort_def
                                      if r16
                                        r16 = SyntaxNode.new(input, (index-1)...index) if r16 == true
                                        r0 = r16
                                      else
                                        r17 = _nt_tckPort_def
                                        if r17
                                          r17 = SyntaxNode.new(input, (index-1)...index) if r17 == true
                                          r0 = r17
                                        else
                                          r18 = _nt_toTckPort_def
                                          if r18
                                            r18 = SyntaxNode.new(input, (index-1)...index) if r18 == true
                                            r0 = r18
                                          else
                                            r19 = _nt_clockPort_def
                                            if r19
                                              r19 = SyntaxNode.new(input, (index-1)...index) if r19 == true
                                              r0 = r19
                                            else
                                              r20 = _nt_toClockPort_def
                                              if r20
                                                r20 = SyntaxNode.new(input, (index-1)...index) if r20 == true
                                                r0 = r20
                                              else
                                                r21 = _nt_trstPort_def
                                                if r21
                                                  r21 = SyntaxNode.new(input, (index-1)...index) if r21 == true
                                                  r0 = r21
                                                else
                                                  r22 = _nt_toTrstPort_def
                                                  if r22
                                                    r22 = SyntaxNode.new(input, (index-1)...index) if r22 == true
                                                    r0 = r22
                                                  else
                                                    r23 = _nt_toIRSelectPort_def
                                                    if r23
                                                      r23 = SyntaxNode.new(input, (index-1)...index) if r23 == true
                                                      r0 = r23
                                                    else
                                                      r24 = _nt_addressPort_def
                                                      if r24
                                                        r24 = SyntaxNode.new(input, (index-1)...index) if r24 == true
                                                        r0 = r24
                                                      else
                                                        r25 = _nt_writeEnPort_def
                                                        if r25
                                                          r25 = SyntaxNode.new(input, (index-1)...index) if r25 == true
                                                          r0 = r25
                                                        else
                                                          r26 = _nt_readEnPort_def
                                                          if r26
                                                            r26 = SyntaxNode.new(input, (index-1)...index) if r26 == true
                                                            r0 = r26
                                                          else
                                                            @index = i0
                                                            r0 = nil
                                                          end
                                                        end
                                                      end
                                                    end
                                                  end
                                                end
                                              end
                                            end
                                          end
                                        end
                                      end
                                    end
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end

        node_cache[:port_def][start_index] = r0

        r0
      end

      module ScanInPortDef0
        def s1
          elements[1]
        end

        def attrs
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module ScanInPortDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def d
          elements[4]
        end

        def s2
          elements[5]
        end
      end

      module ScanInPortDef2
        def to_ast
          if d.respond_to?(:attrs)
            n :scanInPort_def, name.to_ast, *d.attrs.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :scanInPort_def, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_scanInPort_def
        start_index = index
        if node_cache[:scanInPort_def].has_key?(index)
          cached = node_cache[:scanInPort_def][index]
          if cached
            node_cache[:scanInPort_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ScanInPort', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ScanInPort\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_scanInPort_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i7, s7 = index, []
                  if (match_len = has_terminal?('{', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'{\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      s10, i10 = [], index
                      loop do
                        r11 = _nt_attribute_def
                        if r11
                          s10 << r11
                        else
                          break
                        end
                      end
                      r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                      s7 << r10
                      if r10
                        r12 = _nt_s
                        s7 << r12
                        if r12
                          if (match_len = has_terminal?('}', false, index))
                            r13 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'}\'')
                            r13 = nil
                          end
                          s7 << r13
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(ScanInPortDef0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ScanInPortDef1)
          r0.extend(ScanInPortDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:scanInPort_def][start_index] = r0

        r0
      end

      module ScanOutPortDef0
        def s1
          elements[1]
        end

        def items
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module ScanOutPortDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def d
          elements[4]
        end

        def s2
          elements[5]
        end
      end

      module ScanOutPortDef2
        def to_ast
          if d.respond_to?(:items)
            n :scanOutPort_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :scanOutPort_def, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_scanOutPort_def
        start_index = index
        if node_cache[:scanOutPort_def].has_key?(index)
          cached = node_cache[:scanOutPort_def][index]
          if cached
            node_cache[:scanOutPort_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ScanOutPort', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ScanOutPort\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_scanOutPort_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i7, s7 = index, []
                  if (match_len = has_terminal?('{', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'{\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      s10, i10 = [], index
                      loop do
                        r11 = _nt_scanOutPort_item
                        if r11
                          s10 << r11
                        else
                          break
                        end
                      end
                      r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                      s7 << r10
                      if r10
                        r12 = _nt_s
                        s7 << r12
                        if r12
                          if (match_len = has_terminal?('}', false, index))
                            r13 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'}\'')
                            r13 = nil
                          end
                          s7 << r13
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(ScanOutPortDef0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ScanOutPortDef1)
          r0.extend(ScanOutPortDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:scanOutPort_def][start_index] = r0

        r0
      end

      def _nt_scanOutPort_item
        start_index = index
        if node_cache[:scanOutPort_item].has_key?(index)
          cached = node_cache[:scanOutPort_item][index]
          if cached
            node_cache[:scanOutPort_item][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_attribute_def
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_scanOutPort_source
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_scanOutPort_enable
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:scanOutPort_item][start_index] = r0

        r0
      end

      module ScanOutPortSource0
        def S
          elements[1]
        end

        def signal
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module ScanOutPortSource1
        def to_ast
          n :source, signal.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_scanOutPort_source
        start_index = index
        if node_cache[:scanOutPort_source].has_key?(index)
          cached = node_cache[:scanOutPort_source][index]
          if cached
            node_cache[:scanOutPort_source][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('Source', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'Source\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_concat_scan_signal
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ScanOutPortSource0)
          r0.extend(ScanOutPortSource1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:scanOutPort_source][start_index] = r0

        r0
      end

      module ScanOutPortEnable0
        def S
          elements[1]
        end

        def signal
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module ScanOutPortEnable1
        def to_ast
          n :enable, signal.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_scanOutPort_enable
        start_index = index
        if node_cache[:scanOutPort_enable].has_key?(index)
          cached = node_cache[:scanOutPort_enable][index]
          if cached
            node_cache[:scanOutPort_enable][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('Enable', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'Enable\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_data_signal
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ScanOutPortEnable0)
          r0.extend(ScanOutPortEnable1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:scanOutPort_enable][start_index] = r0

        r0
      end

      module ShiftEnPortDef0
        def s1
          elements[1]
        end

        def attrs
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module ShiftEnPortDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def d
          elements[4]
        end

        def s2
          elements[5]
        end
      end

      module ShiftEnPortDef2
        def to_ast
          if d.respond_to?(:attrs)
            n :shiftEnPort_def, name.to_ast, *d.attrs.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :shiftEnPort_def, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_shiftEnPort_def
        start_index = index
        if node_cache[:shiftEnPort_def].has_key?(index)
          cached = node_cache[:shiftEnPort_def][index]
          if cached
            node_cache[:shiftEnPort_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ShiftEnPort', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ShiftEnPort\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_shiftEnPort_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i7, s7 = index, []
                  if (match_len = has_terminal?('{', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'{\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      s10, i10 = [], index
                      loop do
                        r11 = _nt_attribute_def
                        if r11
                          s10 << r11
                        else
                          break
                        end
                      end
                      r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                      s7 << r10
                      if r10
                        r12 = _nt_s
                        s7 << r12
                        if r12
                          if (match_len = has_terminal?('}', false, index))
                            r13 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'}\'')
                            r13 = nil
                          end
                          s7 << r13
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(ShiftEnPortDef0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ShiftEnPortDef1)
          r0.extend(ShiftEnPortDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:shiftEnPort_def][start_index] = r0

        r0
      end

      module CaptureEnPortDef0
        def s1
          elements[1]
        end

        def attrs
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module CaptureEnPortDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def d
          elements[4]
        end

        def s2
          elements[5]
        end
      end

      module CaptureEnPortDef2
        def to_ast
          if d.respond_to?(:attrs)
            n :captureEnPort_def, name.to_ast, *d.attrs.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :captureEnPort_def, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_captureEnPort_def
        start_index = index
        if node_cache[:captureEnPort_def].has_key?(index)
          cached = node_cache[:captureEnPort_def][index]
          if cached
            node_cache[:captureEnPort_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('CaptureEnPort', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'CaptureEnPort\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_captureEnPort_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i7, s7 = index, []
                  if (match_len = has_terminal?('{', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'{\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      s10, i10 = [], index
                      loop do
                        r11 = _nt_attribute_def
                        if r11
                          s10 << r11
                        else
                          break
                        end
                      end
                      r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                      s7 << r10
                      if r10
                        r12 = _nt_s
                        s7 << r12
                        if r12
                          if (match_len = has_terminal?('}', false, index))
                            r13 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'}\'')
                            r13 = nil
                          end
                          s7 << r13
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(CaptureEnPortDef0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(CaptureEnPortDef1)
          r0.extend(CaptureEnPortDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:captureEnPort_def][start_index] = r0

        r0
      end

      module UpdateEnPortDef0
        def s1
          elements[1]
        end

        def attrs
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module UpdateEnPortDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def d
          elements[4]
        end

        def s2
          elements[5]
        end
      end

      module UpdateEnPortDef2
        def to_ast
          if d.respond_to?(:attrs)
            n :updateEnPort_def, name.to_ast, *d.attrs.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :updateEnPort_def, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_updateEnPort_def
        start_index = index
        if node_cache[:updateEnPort_def].has_key?(index)
          cached = node_cache[:updateEnPort_def][index]
          if cached
            node_cache[:updateEnPort_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('UpdateEnPort', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'UpdateEnPort\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_updateEnPort_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i7, s7 = index, []
                  if (match_len = has_terminal?('{', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'{\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      s10, i10 = [], index
                      loop do
                        r11 = _nt_attribute_def
                        if r11
                          s10 << r11
                        else
                          break
                        end
                      end
                      r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                      s7 << r10
                      if r10
                        r12 = _nt_s
                        s7 << r12
                        if r12
                          if (match_len = has_terminal?('}', false, index))
                            r13 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'}\'')
                            r13 = nil
                          end
                          s7 << r13
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(UpdateEnPortDef0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(UpdateEnPortDef1)
          r0.extend(UpdateEnPortDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:updateEnPort_def][start_index] = r0

        r0
      end

      module DataInPortDef0
        def s1
          elements[1]
        end

        def items
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module DataInPortDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def d
          elements[4]
        end

        def s2
          elements[5]
        end
      end

      module DataInPortDef2
        def to_ast
          if d.respond_to?(:items)
            n :dataInPort_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :dataInPort_def, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_dataInPort_def
        start_index = index
        if node_cache[:dataInPort_def].has_key?(index)
          cached = node_cache[:dataInPort_def][index]
          if cached
            node_cache[:dataInPort_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('DataInPort', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'DataInPort\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_dataInPort_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i7, s7 = index, []
                  if (match_len = has_terminal?('{', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'{\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      s10, i10 = [], index
                      loop do
                        r11 = _nt_dataInPort_item
                        if r11
                          s10 << r11
                        else
                          break
                        end
                      end
                      r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                      s7 << r10
                      if r10
                        r12 = _nt_s
                        s7 << r12
                        if r12
                          if (match_len = has_terminal?('}', false, index))
                            r13 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'}\'')
                            r13 = nil
                          end
                          s7 << r13
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(DataInPortDef0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DataInPortDef1)
          r0.extend(DataInPortDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:dataInPort_def][start_index] = r0

        r0
      end

      def _nt_dataInPort_item
        start_index = index
        if node_cache[:dataInPort_item].has_key?(index)
          cached = node_cache[:dataInPort_item][index]
          if cached
            node_cache[:dataInPort_item][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_attribute_def
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_dataInPort_refEnum
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_dataInPort_defaultLoadValue
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:dataInPort_item][start_index] = r0

        r0
      end

      module DataInPortRefEnum0
        def s1
          elements[1]
        end

        def name
          elements[2]
        end

        def s2
          elements[3]
        end

        def s3
          elements[5]
        end
      end

      module DataInPortRefEnum1
        def to_ast
          n :refEnum, name.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_dataInPort_refEnum
        start_index = index
        if node_cache[:dataInPort_refEnum].has_key?(index)
          cached = node_cache[:dataInPort_refEnum][index]
          if cached
            node_cache[:dataInPort_refEnum][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('RefEnum', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'RefEnum\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            r3 = _nt_enum_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DataInPortRefEnum0)
          r0.extend(DataInPortRefEnum1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:dataInPort_refEnum][start_index] = r0

        r0
      end

      module DataInPortDefaultLoadValue0
        def S
          elements[1]
        end

        def val
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module DataInPortDefaultLoadValue1
        def to_ast
          n :defaultLoadValue, val.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_dataInPort_defaultLoadValue
        start_index = index
        if node_cache[:dataInPort_defaultLoadValue].has_key?(index)
          cached = node_cache[:dataInPort_defaultLoadValue][index]
          if cached
            node_cache[:dataInPort_defaultLoadValue][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('DefaultLoadValue', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'DefaultLoadValue\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            i3 = index
            r4 = _nt_concat_number
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r3 = r4
            else
              r5 = _nt_enum_symbol
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r3 = r5
              else
                @index = i3
                r3 = nil
              end
            end
            s0 << r3
            if r3
              r6 = _nt_s
              s0 << r6
              if r6
                if (match_len = has_terminal?(';', false, index))
                  r7 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r7 = nil
                end
                s0 << r7
                if r7
                  r8 = _nt_s
                  s0 << r8
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DataInPortDefaultLoadValue0)
          r0.extend(DataInPortDefaultLoadValue1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:dataInPort_defaultLoadValue][start_index] = r0

        r0
      end

      module DataOutPortDef0
        def s1
          elements[1]
        end

        def items
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module DataOutPortDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def d
          elements[4]
        end

        def s2
          elements[5]
        end
      end

      module DataOutPortDef2
        def to_ast
          if d.respond_to?(:items)
            n :dataOutPort_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :dataOutPort_def, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_dataOutPort_def
        start_index = index
        if node_cache[:dataOutPort_def].has_key?(index)
          cached = node_cache[:dataOutPort_def][index]
          if cached
            node_cache[:dataOutPort_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('DataOutPort', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'DataOutPort\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_dataOutPort_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i7, s7 = index, []
                  if (match_len = has_terminal?('{', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'{\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      s10, i10 = [], index
                      loop do
                        r11 = _nt_dataOutPort_item
                        if r11
                          s10 << r11
                        else
                          break
                        end
                      end
                      r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                      s7 << r10
                      if r10
                        r12 = _nt_s
                        s7 << r12
                        if r12
                          if (match_len = has_terminal?('}', false, index))
                            r13 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'}\'')
                            r13 = nil
                          end
                          s7 << r13
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(DataOutPortDef0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DataOutPortDef1)
          r0.extend(DataOutPortDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:dataOutPort_def][start_index] = r0

        r0
      end

      def _nt_dataOutPort_item
        start_index = index
        if node_cache[:dataOutPort_item].has_key?(index)
          cached = node_cache[:dataOutPort_item][index]
          if cached
            node_cache[:dataOutPort_item][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_attribute_def
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_dataOutPort_source
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_dataOutPort_enable
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              r4 = _nt_dataOutPort_refEnum
              if r4
                r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
                r0 = r4
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end

        node_cache[:dataOutPort_item][start_index] = r0

        r0
      end

      module DataOutPortSource0
        def S
          elements[1]
        end

        def signal
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module DataOutPortSource1
        def to_ast
          n :source, signal.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_dataOutPort_source
        start_index = index
        if node_cache[:dataOutPort_source].has_key?(index)
          cached = node_cache[:dataOutPort_source][index]
          if cached
            node_cache[:dataOutPort_source][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('Source', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'Source\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_concat_data_signal
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DataOutPortSource0)
          r0.extend(DataOutPortSource1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:dataOutPort_source][start_index] = r0

        r0
      end

      module DataOutPortEnable0
        def S
          elements[1]
        end

        def signal
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module DataOutPortEnable1
        def to_ast
          n :enable, signal.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_dataOutPort_enable
        start_index = index
        if node_cache[:dataOutPort_enable].has_key?(index)
          cached = node_cache[:dataOutPort_enable][index]
          if cached
            node_cache[:dataOutPort_enable][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('Enable', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'Enable\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_data_signal
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DataOutPortEnable0)
          r0.extend(DataOutPortEnable1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:dataOutPort_enable][start_index] = r0

        r0
      end

      module DataOutPortRefEnum0
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module DataOutPortRefEnum1
        def to_ast
          n :refEnum, name.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_dataOutPort_refEnum
        start_index = index
        if node_cache[:dataOutPort_refEnum].has_key?(index)
          cached = node_cache[:dataOutPort_refEnum][index]
          if cached
            node_cache[:dataOutPort_refEnum][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('RefEnum', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'RefEnum\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_enum_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DataOutPortRefEnum0)
          r0.extend(DataOutPortRefEnum1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:dataOutPort_refEnum][start_index] = r0

        r0
      end

      module ToShiftEnPortDef0
        def s1
          elements[1]
        end

        def items
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module ToShiftEnPortDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def d
          elements[4]
        end

        def s2
          elements[5]
        end
      end

      module ToShiftEnPortDef2
        def to_ast
          if d.respond_to?(:items)
            n :toShiftEnPort_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :toShiftEnPort_def, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_toShiftEnPort_def
        start_index = index
        if node_cache[:toShiftEnPort_def].has_key?(index)
          cached = node_cache[:toShiftEnPort_def][index]
          if cached
            node_cache[:toShiftEnPort_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ToShiftEnPort', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ToShiftEnPort\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_toShiftEnPort_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i7, s7 = index, []
                  if (match_len = has_terminal?('{', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'{\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      s10, i10 = [], index
                      loop do
                        r11 = _nt_toShiftEnPort_items
                        if r11
                          s10 << r11
                        else
                          break
                        end
                      end
                      r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                      s7 << r10
                      if r10
                        r12 = _nt_s
                        s7 << r12
                        if r12
                          if (match_len = has_terminal?('}', false, index))
                            r13 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'}\'')
                            r13 = nil
                          end
                          s7 << r13
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(ToShiftEnPortDef0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ToShiftEnPortDef1)
          r0.extend(ToShiftEnPortDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:toShiftEnPort_def][start_index] = r0

        r0
      end

      def _nt_toShiftEnPort_items
        start_index = index
        if node_cache[:toShiftEnPort_items].has_key?(index)
          cached = node_cache[:toShiftEnPort_items][index]
          if cached
            node_cache[:toShiftEnPort_items][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_attribute_def
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_toShiftEnPort_source
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:toShiftEnPort_items][start_index] = r0

        r0
      end

      module ToShiftEnPortSource0
        def S
          elements[1]
        end

        def signal
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module ToShiftEnPortSource1
        def to_ast
          n :source, signal.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_toShiftEnPort_source
        start_index = index
        if node_cache[:toShiftEnPort_source].has_key?(index)
          cached = node_cache[:toShiftEnPort_source][index]
          if cached
            node_cache[:toShiftEnPort_source][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('Source', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'Source\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_concat_shiftEn_signal
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ToShiftEnPortSource0)
          r0.extend(ToShiftEnPortSource1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:toShiftEnPort_source][start_index] = r0

        r0
      end

      module ToCaptureEnPortDef0
        def s1
          elements[1]
        end

        def items
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module ToCaptureEnPortDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def d
          elements[4]
        end

        def s2
          elements[5]
        end
      end

      module ToCaptureEnPortDef2
        def to_ast
          if d.respond_to?(:items)
            n :toCaptureEnPort_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :toCaptureEnPort_def, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_toCaptureEnPort_def
        start_index = index
        if node_cache[:toCaptureEnPort_def].has_key?(index)
          cached = node_cache[:toCaptureEnPort_def][index]
          if cached
            node_cache[:toCaptureEnPort_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ToCaptureEnPort', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ToCaptureEnPort\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_toCaptureEnPort_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i7, s7 = index, []
                  if (match_len = has_terminal?('{', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'{\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      s10, i10 = [], index
                      loop do
                        r11 = _nt_toCaptureEnPort_items
                        if r11
                          s10 << r11
                        else
                          break
                        end
                      end
                      r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                      s7 << r10
                      if r10
                        r12 = _nt_s
                        s7 << r12
                        if r12
                          if (match_len = has_terminal?('}', false, index))
                            r13 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'}\'')
                            r13 = nil
                          end
                          s7 << r13
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(ToCaptureEnPortDef0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ToCaptureEnPortDef1)
          r0.extend(ToCaptureEnPortDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:toCaptureEnPort_def][start_index] = r0

        r0
      end

      def _nt_toCaptureEnPort_items
        start_index = index
        if node_cache[:toCaptureEnPort_items].has_key?(index)
          cached = node_cache[:toCaptureEnPort_items][index]
          if cached
            node_cache[:toCaptureEnPort_items][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_attribute_def
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_toCaptureEnPort_source
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:toCaptureEnPort_items][start_index] = r0

        r0
      end

      module ToCaptureEnPortSource0
        def S
          elements[1]
        end

        def signal
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module ToCaptureEnPortSource1
        def to_ast
          n :source, signal.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_toCaptureEnPort_source
        start_index = index
        if node_cache[:toCaptureEnPort_source].has_key?(index)
          cached = node_cache[:toCaptureEnPort_source][index]
          if cached
            node_cache[:toCaptureEnPort_source][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('Source', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'Source\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_captureEn_signal
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ToCaptureEnPortSource0)
          r0.extend(ToCaptureEnPortSource1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:toCaptureEnPort_source][start_index] = r0

        r0
      end

      module ToUpdateEnPortDef0
        def s1
          elements[1]
        end

        def items
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module ToUpdateEnPortDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def d
          elements[4]
        end

        def s2
          elements[5]
        end
      end

      module ToUpdateEnPortDef2
        def to_ast
          if d.respond_to?(:items)
            n :toUpdateEnPort_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :toUpdateEnPort_def, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_toUpdateEnPort_def
        start_index = index
        if node_cache[:toUpdateEnPort_def].has_key?(index)
          cached = node_cache[:toUpdateEnPort_def][index]
          if cached
            node_cache[:toUpdateEnPort_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ToUpdateEnPort', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ToUpdateEnPort\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_toUpdateEnPort_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i7, s7 = index, []
                  if (match_len = has_terminal?('{', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'{\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      s10, i10 = [], index
                      loop do
                        r11 = _nt_toUpdateEnPort_items
                        if r11
                          s10 << r11
                        else
                          break
                        end
                      end
                      r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                      s7 << r10
                      if r10
                        r12 = _nt_s
                        s7 << r12
                        if r12
                          if (match_len = has_terminal?('}', false, index))
                            r13 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'}\'')
                            r13 = nil
                          end
                          s7 << r13
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(ToUpdateEnPortDef0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ToUpdateEnPortDef1)
          r0.extend(ToUpdateEnPortDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:toUpdateEnPort_def][start_index] = r0

        r0
      end

      def _nt_toUpdateEnPort_items
        start_index = index
        if node_cache[:toUpdateEnPort_items].has_key?(index)
          cached = node_cache[:toUpdateEnPort_items][index]
          if cached
            node_cache[:toUpdateEnPort_items][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_attribute_def
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_toUpdateEnPort_source
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:toUpdateEnPort_items][start_index] = r0

        r0
      end

      module ToUpdateEnPortSource0
        def S
          elements[1]
        end

        def signal
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module ToUpdateEnPortSource1
        def to_ast
          n :source, signal.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_toUpdateEnPort_source
        start_index = index
        if node_cache[:toUpdateEnPort_source].has_key?(index)
          cached = node_cache[:toUpdateEnPort_source][index]
          if cached
            node_cache[:toUpdateEnPort_source][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('Source', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'Source\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_updateEn_signal
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ToUpdateEnPortSource0)
          r0.extend(ToUpdateEnPortSource1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:toUpdateEnPort_source][start_index] = r0

        r0
      end

      module SelectPortDef0
        def s1
          elements[1]
        end

        def attrs
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module SelectPortDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def d
          elements[4]
        end

        def s2
          elements[5]
        end
      end

      module SelectPortDef2
        def to_ast
          if d.respond_to?(:attrs)
            n :selectPort_def, name.to_ast, *d.attrs.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :selectPort_def, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_selectPort_def
        start_index = index
        if node_cache[:selectPort_def].has_key?(index)
          cached = node_cache[:selectPort_def][index]
          if cached
            node_cache[:selectPort_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('SelectPort', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'SelectPort\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_selectPort_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i7, s7 = index, []
                  if (match_len = has_terminal?('{', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'{\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      s10, i10 = [], index
                      loop do
                        r11 = _nt_attribute_def
                        if r11
                          s10 << r11
                        else
                          break
                        end
                      end
                      r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                      s7 << r10
                      if r10
                        r12 = _nt_s
                        s7 << r12
                        if r12
                          if (match_len = has_terminal?('}', false, index))
                            r13 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'}\'')
                            r13 = nil
                          end
                          s7 << r13
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(SelectPortDef0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SelectPortDef1)
          r0.extend(SelectPortDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:selectPort_def][start_index] = r0

        r0
      end

      module ToSelectPortDef0
        def s1
          elements[1]
        end

        def items
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module ToSelectPortDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def d
          elements[4]
        end

        def s2
          elements[5]
        end
      end

      module ToSelectPortDef2
        def to_ast
          if d.respond_to?(:items)
            n :toSelectPort_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :toSelectPort_def, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_toSelectPort_def
        start_index = index
        if node_cache[:toSelectPort_def].has_key?(index)
          cached = node_cache[:toSelectPort_def][index]
          if cached
            node_cache[:toSelectPort_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ToSelectPort', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ToSelectPort\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_toSelectPort_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i7, s7 = index, []
                  if (match_len = has_terminal?('{', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'{\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      s10, i10 = [], index
                      loop do
                        r11 = _nt_toSelectPort_item
                        if r11
                          s10 << r11
                        else
                          break
                        end
                      end
                      if s10.empty?
                        @index = i10
                        r10 = nil
                      else
                        r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                      end
                      s7 << r10
                      if r10
                        r12 = _nt_s
                        s7 << r12
                        if r12
                          if (match_len = has_terminal?('}', false, index))
                            r13 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'}\'')
                            r13 = nil
                          end
                          s7 << r13
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(ToSelectPortDef0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ToSelectPortDef1)
          r0.extend(ToSelectPortDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:toSelectPort_def][start_index] = r0

        r0
      end

      def _nt_toSelectPort_item
        start_index = index
        if node_cache[:toSelectPort_item].has_key?(index)
          cached = node_cache[:toSelectPort_item][index]
          if cached
            node_cache[:toSelectPort_item][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_attribute_def
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_toSelectPort_source
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:toSelectPort_item][start_index] = r0

        r0
      end

      module ToSelectPortSource0
        def S
          elements[1]
        end

        def signal
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module ToSelectPortSource1
        def to_ast
          n :source, signal.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_toSelectPort_source
        start_index = index
        if node_cache[:toSelectPort_source].has_key?(index)
          cached = node_cache[:toSelectPort_source][index]
          if cached
            node_cache[:toSelectPort_source][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('Source', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'Source\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_concat_data_signal
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ToSelectPortSource0)
          r0.extend(ToSelectPortSource1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:toSelectPort_source][start_index] = r0

        r0
      end

      module ResetPortDef0
        def s1
          elements[1]
        end

        def items
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module ResetPortDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def d
          elements[4]
        end

        def s2
          elements[5]
        end
      end

      module ResetPortDef2
        def to_ast
          if d.respond_to?(:items)
            n :resetPort_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :resetPort_def, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_resetPort_def
        start_index = index
        if node_cache[:resetPort_def].has_key?(index)
          cached = node_cache[:resetPort_def][index]
          if cached
            node_cache[:resetPort_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ResetPort', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ResetPort\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_resetPort_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i7, s7 = index, []
                  if (match_len = has_terminal?('{', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'{\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      s10, i10 = [], index
                      loop do
                        r11 = _nt_resetPort_item
                        if r11
                          s10 << r11
                        else
                          break
                        end
                      end
                      r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                      s7 << r10
                      if r10
                        r12 = _nt_s
                        s7 << r12
                        if r12
                          if (match_len = has_terminal?('}', false, index))
                            r13 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'}\'')
                            r13 = nil
                          end
                          s7 << r13
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(ResetPortDef0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ResetPortDef1)
          r0.extend(ResetPortDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:resetPort_def][start_index] = r0

        r0
      end

      def _nt_resetPort_item
        start_index = index
        if node_cache[:resetPort_item].has_key?(index)
          cached = node_cache[:resetPort_item][index]
          if cached
            node_cache[:resetPort_item][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_attribute_def
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_resetPort_polarity
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:resetPort_item][start_index] = r0

        r0
      end

      module ResetPortPolarity0
        def S
          elements[1]
        end

        def val
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module ResetPortPolarity1
        def to_ast
          n :resetPort_polarity, val.text_value.to_i, input: input, interval: interval, file: file
        end
      end

      def _nt_resetPort_polarity
        start_index = index
        if node_cache[:resetPort_polarity].has_key?(index)
          cached = node_cache[:resetPort_polarity][index]
          if cached
            node_cache[:resetPort_polarity][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ActivePolarity', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ActivePolarity\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            i3 = index
            if (match_len = has_terminal?('0', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure('\'0\'')
              r4 = nil
            end
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r3 = r4
            else
              if (match_len = has_terminal?('1', false, index))
                r5 = true
                @index += match_len
              else
                terminal_parse_failure('\'1\'')
                r5 = nil
              end
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r3 = r5
              else
                @index = i3
                r3 = nil
              end
            end
            s0 << r3
            if r3
              r6 = _nt_s
              s0 << r6
              if r6
                if (match_len = has_terminal?(';', false, index))
                  r7 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r7 = nil
                end
                s0 << r7
                if r7
                  r8 = _nt_s
                  s0 << r8
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ResetPortPolarity0)
          r0.extend(ResetPortPolarity1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:resetPort_polarity][start_index] = r0

        r0
      end

      module ToResetPortDef0
        def s1
          elements[1]
        end

        def items
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module ToResetPortDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def d
          elements[4]
        end

        def s2
          elements[5]
        end
      end

      module ToResetPortDef2
        def to_ast
          if d.respond_to?(:items)
            n :toResetPort_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :toResetPort_def, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_toResetPort_def
        start_index = index
        if node_cache[:toResetPort_def].has_key?(index)
          cached = node_cache[:toResetPort_def][index]
          if cached
            node_cache[:toResetPort_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ToResetPort', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ToResetPort\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_toResetPort_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i7, s7 = index, []
                  if (match_len = has_terminal?('{', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'{\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      s10, i10 = [], index
                      loop do
                        r11 = _nt_toResetPort_item
                        if r11
                          s10 << r11
                        else
                          break
                        end
                      end
                      if s10.empty?
                        @index = i10
                        r10 = nil
                      else
                        r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                      end
                      s7 << r10
                      if r10
                        r12 = _nt_s
                        s7 << r12
                        if r12
                          if (match_len = has_terminal?('}', false, index))
                            r13 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'}\'')
                            r13 = nil
                          end
                          s7 << r13
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(ToResetPortDef0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ToResetPortDef1)
          r0.extend(ToResetPortDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:toResetPort_def][start_index] = r0

        r0
      end

      def _nt_toResetPort_item
        start_index = index
        if node_cache[:toResetPort_item].has_key?(index)
          cached = node_cache[:toResetPort_item][index]
          if cached
            node_cache[:toResetPort_item][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_attribute_def
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_toResetPort_source
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_toResetPort_polarity
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:toResetPort_item][start_index] = r0

        r0
      end

      module ToResetPortSource0
        def S
          elements[1]
        end

        def signal
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module ToResetPortSource1
        def to_ast
          n :source, signal.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_toResetPort_source
        start_index = index
        if node_cache[:toResetPort_source].has_key?(index)
          cached = node_cache[:toResetPort_source][index]
          if cached
            node_cache[:toResetPort_source][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('Source', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'Source\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_concat_reset_signal
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ToResetPortSource0)
          r0.extend(ToResetPortSource1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:toResetPort_source][start_index] = r0

        r0
      end

      module ToResetPortPolarity0
        def S
          elements[1]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module ToResetPortPolarity1
        def to_ast
          n :resetPort_polarity, val.text_value.to_i, input: input, interval: interval, file: file
        end
      end

      def _nt_toResetPort_polarity
        start_index = index
        if node_cache[:toResetPort_polarity].has_key?(index)
          cached = node_cache[:toResetPort_polarity][index]
          if cached
            node_cache[:toResetPort_polarity][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ActivePolarity', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ActivePolarity\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            i3 = index
            if (match_len = has_terminal?('0', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure('\'0\'')
              r4 = nil
            end
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r3 = r4
            else
              if (match_len = has_terminal?('1', false, index))
                r5 = true
                @index += match_len
              else
                terminal_parse_failure('\'1\'')
                r5 = nil
              end
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r3 = r5
              else
                @index = i3
                r3 = nil
              end
            end
            s0 << r3
            if r3
              r6 = _nt_s
              s0 << r6
              if r6
                if (match_len = has_terminal?(';', false, index))
                  r7 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r7 = nil
                end
                s0 << r7
                if r7
                  r8 = _nt_s
                  s0 << r8
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ToResetPortPolarity0)
          r0.extend(ToResetPortPolarity1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:toResetPort_polarity][start_index] = r0

        r0
      end

      module TmsPortDef0
        def s1
          elements[1]
        end

        def attrs
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module TmsPortDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def d
          elements[4]
        end

        def s2
          elements[5]
        end
      end

      module TmsPortDef2
        def to_ast
          if d.respond_to?(:attrs)
            n :tmsPort_name, name.to_ast, *d.attrs.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :tmsPort_name, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_tmsPort_def
        start_index = index
        if node_cache[:tmsPort_def].has_key?(index)
          cached = node_cache[:tmsPort_def][index]
          if cached
            node_cache[:tmsPort_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('TMSPort', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'TMSPort\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_tmsPort_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i7, s7 = index, []
                  if (match_len = has_terminal?('{', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'{\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      s10, i10 = [], index
                      loop do
                        r11 = _nt_attribute_def
                        if r11
                          s10 << r11
                        else
                          break
                        end
                      end
                      r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                      s7 << r10
                      if r10
                        r12 = _nt_s
                        s7 << r12
                        if r12
                          if (match_len = has_terminal?('}', false, index))
                            r13 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'}\'')
                            r13 = nil
                          end
                          s7 << r13
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(TmsPortDef0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(TmsPortDef1)
          r0.extend(TmsPortDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:tmsPort_def][start_index] = r0

        r0
      end

      module ToTmsPortDef0
        def s1
          elements[1]
        end

        def items
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module ToTmsPortDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def d
          elements[4]
        end

        def s2
          elements[5]
        end
      end

      module ToTmsPortDef2
        def to_ast
          if d.respond_to?(:items)
            n :toTmsPort_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :toTmsPort_def, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_toTmsPort_def
        start_index = index
        if node_cache[:toTmsPort_def].has_key?(index)
          cached = node_cache[:toTmsPort_def][index]
          if cached
            node_cache[:toTmsPort_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ToTMSPort', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ToTMSPort\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_toTmsPort_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i7, s7 = index, []
                  if (match_len = has_terminal?('{', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'{\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      s10, i10 = [], index
                      loop do
                        r11 = _nt_toTmsPort_item
                        if r11
                          s10 << r11
                        else
                          break
                        end
                      end
                      r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                      s7 << r10
                      if r10
                        r12 = _nt_s
                        s7 << r12
                        if r12
                          if (match_len = has_terminal?('}', false, index))
                            r13 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'}\'')
                            r13 = nil
                          end
                          s7 << r13
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(ToTmsPortDef0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ToTmsPortDef1)
          r0.extend(ToTmsPortDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:toTmsPort_def][start_index] = r0

        r0
      end

      def _nt_toTmsPort_item
        start_index = index
        if node_cache[:toTmsPort_item].has_key?(index)
          cached = node_cache[:toTmsPort_item][index]
          if cached
            node_cache[:toTmsPort_item][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_attribute_def
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_toTmsPort_source
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:toTmsPort_item][start_index] = r0

        r0
      end

      module ToTmsPortSource0
        def S
          elements[1]
        end

        def signal
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module ToTmsPortSource1
        def to_ast
          n :source, signal.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_toTmsPort_source
        start_index = index
        if node_cache[:toTmsPort_source].has_key?(index)
          cached = node_cache[:toTmsPort_source][index]
          if cached
            node_cache[:toTmsPort_source][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('Source', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'Source\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_concat_tms_signal
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ToTmsPortSource0)
          r0.extend(ToTmsPortSource1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:toTmsPort_source][start_index] = r0

        r0
      end

      module ToIRSelectPortDef0
        def s1
          elements[1]
        end

        def attrs
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module ToIRSelectPortDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def d
          elements[4]
        end

        def s2
          elements[5]
        end
      end

      module ToIRSelectPortDef2
        def to_ast
          if d.respond_to?(:attrs)
            n :toIRSelectPort_def, name.to_ast, *d.attrs.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :toIRSelectPort_def, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_toIRSelectPort_def
        start_index = index
        if node_cache[:toIRSelectPort_def].has_key?(index)
          cached = node_cache[:toIRSelectPort_def][index]
          if cached
            node_cache[:toIRSelectPort_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ToIRSelectPort', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ToIRSelectPort\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_toIRSelectPort_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i7, s7 = index, []
                  if (match_len = has_terminal?('{', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'{\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      s10, i10 = [], index
                      loop do
                        r11 = _nt_attribute_def
                        if r11
                          s10 << r11
                        else
                          break
                        end
                      end
                      r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                      s7 << r10
                      if r10
                        r12 = _nt_s
                        s7 << r12
                        if r12
                          if (match_len = has_terminal?('}', false, index))
                            r13 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'}\'')
                            r13 = nil
                          end
                          s7 << r13
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(ToIRSelectPortDef0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ToIRSelectPortDef1)
          r0.extend(ToIRSelectPortDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:toIRSelectPort_def][start_index] = r0

        r0
      end

      module TckPortDef0
        def s1
          elements[1]
        end

        def attrs
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module TckPortDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def d
          elements[4]
        end

        def s2
          elements[5]
        end
      end

      module TckPortDef2
        def to_ast
          if d.respond_to?(:attrs)
            n :tckPort_def, name.to_ast, *d.attrs.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :tckPort_def, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_tckPort_def
        start_index = index
        if node_cache[:tckPort_def].has_key?(index)
          cached = node_cache[:tckPort_def][index]
          if cached
            node_cache[:tckPort_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('TCKPort', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'TCKPort\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_tckPort_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i7, s7 = index, []
                  if (match_len = has_terminal?('{', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'{\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      s10, i10 = [], index
                      loop do
                        r11 = _nt_attribute_def
                        if r11
                          s10 << r11
                        else
                          break
                        end
                      end
                      r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                      s7 << r10
                      if r10
                        r12 = _nt_s
                        s7 << r12
                        if r12
                          if (match_len = has_terminal?('}', false, index))
                            r13 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'}\'')
                            r13 = nil
                          end
                          s7 << r13
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(TckPortDef0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(TckPortDef1)
          r0.extend(TckPortDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:tckPort_def][start_index] = r0

        r0
      end

      module ToTckPortDef0
        def s1
          elements[1]
        end

        def attrs
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module ToTckPortDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def d
          elements[4]
        end

        def s2
          elements[5]
        end
      end

      module ToTckPortDef2
        def to_ast
          if d.respond_to?(:attrs)
            n :toTckPort_def, name.to_ast, *d.attrs.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :toTckPort_def, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_toTckPort_def
        start_index = index
        if node_cache[:toTckPort_def].has_key?(index)
          cached = node_cache[:toTckPort_def][index]
          if cached
            node_cache[:toTckPort_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ToTCKPort', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ToTCKPort\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_toTckPort_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i7, s7 = index, []
                  if (match_len = has_terminal?('{', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'{\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      s10, i10 = [], index
                      loop do
                        r11 = _nt_attribute_def
                        if r11
                          s10 << r11
                        else
                          break
                        end
                      end
                      r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                      s7 << r10
                      if r10
                        r12 = _nt_s
                        s7 << r12
                        if r12
                          if (match_len = has_terminal?('}', false, index))
                            r13 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'}\'')
                            r13 = nil
                          end
                          s7 << r13
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(ToTckPortDef0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ToTckPortDef1)
          r0.extend(ToTckPortDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:toTckPort_def][start_index] = r0

        r0
      end

      module ClockPortDef0
        def s1
          elements[1]
        end

        def items
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module ClockPortDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def d
          elements[4]
        end

        def s2
          elements[5]
        end
      end

      module ClockPortDef2
        def to_ast
          if d.respond_to?(:items)
            n :clockPort_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :clockPort_def, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_clockPort_def
        start_index = index
        if node_cache[:clockPort_def].has_key?(index)
          cached = node_cache[:clockPort_def][index]
          if cached
            node_cache[:clockPort_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ClockPort', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ClockPort\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_clockPort_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i7, s7 = index, []
                  if (match_len = has_terminal?('{', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'{\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      s10, i10 = [], index
                      loop do
                        r11 = _nt_clockPort_item
                        if r11
                          s10 << r11
                        else
                          break
                        end
                      end
                      r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                      s7 << r10
                      if r10
                        r12 = _nt_s
                        s7 << r12
                        if r12
                          if (match_len = has_terminal?('}', false, index))
                            r13 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'}\'')
                            r13 = nil
                          end
                          s7 << r13
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(ClockPortDef0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ClockPortDef1)
          r0.extend(ClockPortDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:clockPort_def][start_index] = r0

        r0
      end

      def _nt_clockPort_item
        start_index = index
        if node_cache[:clockPort_item].has_key?(index)
          cached = node_cache[:clockPort_item][index]
          if cached
            node_cache[:clockPort_item][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_attribute_def
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_clockPort_diffPort
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:clockPort_item][start_index] = r0

        r0
      end

      module ClockPortDiffPort0
        def S
          elements[1]
        end

        def signal
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module ClockPortDiffPort1
        def to_ast
          n :clockPort_diffPort, signal.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_clockPort_diffPort
        start_index = index
        if node_cache[:clockPort_diffPort].has_key?(index)
          cached = node_cache[:clockPort_diffPort][index]
          if cached
            node_cache[:clockPort_diffPort][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('DifferentialInvOf', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'DifferentialInvOf\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_concat_clock_signal
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ClockPortDiffPort0)
          r0.extend(ClockPortDiffPort1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:clockPort_diffPort][start_index] = r0

        r0
      end

      module ToClockPortDef0
        def s1
          elements[1]
        end

        def items
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module ToClockPortDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def d
          elements[4]
        end

        def s2
          elements[5]
        end
      end

      module ToClockPortDef2
        def to_ast
          if d.respond_to?(:items)
            n :toClockPort_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :toClockPort_def, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_toClockPort_def
        start_index = index
        if node_cache[:toClockPort_def].has_key?(index)
          cached = node_cache[:toClockPort_def][index]
          if cached
            node_cache[:toClockPort_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ToClockPort', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ToClockPort\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_toClockPort_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i7, s7 = index, []
                  if (match_len = has_terminal?('{', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'{\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      s10, i10 = [], index
                      loop do
                        r11 = _nt_toClockPort_item
                        if r11
                          s10 << r11
                        else
                          break
                        end
                      end
                      if s10.empty?
                        @index = i10
                        r10 = nil
                      else
                        r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                      end
                      s7 << r10
                      if r10
                        r12 = _nt_s
                        s7 << r12
                        if r12
                          if (match_len = has_terminal?('}', false, index))
                            r13 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'}\'')
                            r13 = nil
                          end
                          s7 << r13
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(ToClockPortDef0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ToClockPortDef1)
          r0.extend(ToClockPortDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:toClockPort_def][start_index] = r0

        r0
      end

      def _nt_toClockPort_item
        start_index = index
        if node_cache[:toClockPort_item].has_key?(index)
          cached = node_cache[:toClockPort_item][index]
          if cached
            node_cache[:toClockPort_item][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_attribute_def
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_toClockPort_source
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_freqMultiplier_def
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              r4 = _nt_freqDivider_def
              if r4
                r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
                r0 = r4
              else
                r5 = _nt_differentialInvOf_def
                if r5
                  r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                  r0 = r5
                else
                  r6 = _nt_period_def
                  if r6
                    r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                    r0 = r6
                  else
                    @index = i0
                    r0 = nil
                  end
                end
              end
            end
          end
        end

        node_cache[:toClockPort_item][start_index] = r0

        r0
      end

      module ToClockPortSource0
        def S
          elements[1]
        end

        def signal
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module ToClockPortSource1
        def to_ast
          n :source, signal.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_toClockPort_source
        start_index = index
        if node_cache[:toClockPort_source].has_key?(index)
          cached = node_cache[:toClockPort_source][index]
          if cached
            node_cache[:toClockPort_source][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('Source', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'Source\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_concat_clock_signal
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ToClockPortSource0)
          r0.extend(ToClockPortSource1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:toClockPort_source][start_index] = r0

        r0
      end

      module FreqMultiplierDef0
        def S
          elements[1]
        end

        def val
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module FreqMultiplierDef1
        def to_ast
          n :freqMultiplier_def, val.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_freqMultiplier_def
        start_index = index
        if node_cache[:freqMultiplier_def].has_key?(index)
          cached = node_cache[:freqMultiplier_def][index]
          if cached
            node_cache[:freqMultiplier_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('FreqMultiplier', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'FreqMultiplier\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_POS_INT
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(FreqMultiplierDef0)
          r0.extend(FreqMultiplierDef1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:freqMultiplier_def][start_index] = r0

        r0
      end

      module FreqDividerDef0
        def S
          elements[1]
        end

        def val
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module FreqDividerDef1
        def to_ast
          n :freqDivider_def, val.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_freqDivider_def
        start_index = index
        if node_cache[:freqDivider_def].has_key?(index)
          cached = node_cache[:freqDivider_def][index]
          if cached
            node_cache[:freqDivider_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('FreqDivider', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'FreqDivider\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_POS_INT
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(FreqDividerDef0)
          r0.extend(FreqDividerDef1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:freqDivider_def][start_index] = r0

        r0
      end

      module DifferentialInvOfDef0
        def S
          elements[1]
        end

        def val
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module DifferentialInvOfDef1
        def to_ast
          n :differentialInvOf_def, val.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_differentialInvOf_def
        start_index = index
        if node_cache[:differentialInvOf_def].has_key?(index)
          cached = node_cache[:differentialInvOf_def][index]
          if cached
            node_cache[:differentialInvOf_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('DifferentialInvOf', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'DifferentialInvOf\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_concat_clock_signal
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DifferentialInvOfDef0)
          r0.extend(DifferentialInvOfDef1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:differentialInvOf_def][start_index] = r0

        r0
      end

      module PeriodDef0
        def S
          elements[1]
        end

        def val
          elements[2]
        end

        def s1
          elements[3]
        end

        def unit
          elements[4]
        end

        def s2
          elements[5]
        end

        def s3
          elements[7]
        end
      end

      module PeriodDef1
        def to_ast
          n :period_def, "#{v.to_ast}#{unit}", input: input, interval: interval, file: file
        end
      end

      def _nt_period_def
        start_index = index
        if node_cache[:period_def].has_key?(index)
          cached = node_cache[:period_def][index]
          if cached
            node_cache[:period_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('Period', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'Period\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_POS_INT
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i6 = index
                if (match_len = has_terminal?('s', false, index))
                  r7 = true
                  @index += match_len
                else
                  terminal_parse_failure('\'s\'')
                  r7 = nil
                end
                if r7
                  r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                  r6 = r7
                else
                  if (match_len = has_terminal?('ms', false, index))
                    r8 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('\'ms\'')
                    r8 = nil
                  end
                  if r8
                    r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
                    r6 = r8
                  else
                    if (match_len = has_terminal?('us', false, index))
                      r9 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                      @index += match_len
                    else
                      terminal_parse_failure('\'us\'')
                      r9 = nil
                    end
                    if r9
                      r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
                      r6 = r9
                    else
                      if (match_len = has_terminal?('ns', false, index))
                        r10 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                        @index += match_len
                      else
                        terminal_parse_failure('\'ns\'')
                        r10 = nil
                      end
                      if r10
                        r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                        r6 = r10
                      else
                        if (match_len = has_terminal?('ps', false, index))
                          r11 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                          @index += match_len
                        else
                          terminal_parse_failure('\'ps\'')
                          r11 = nil
                        end
                        if r11
                          r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
                          r6 = r11
                        else
                          if (match_len = has_terminal?('fs', false, index))
                            r12 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                            @index += match_len
                          else
                            terminal_parse_failure('\'fs\'')
                            r12 = nil
                          end
                          if r12
                            r12 = SyntaxNode.new(input, (index-1)...index) if r12 == true
                            r6 = r12
                          else
                            if (match_len = has_terminal?('as', false, index))
                              r13 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                              @index += match_len
                            else
                              terminal_parse_failure('\'as\'')
                              r13 = nil
                            end
                            if r13
                              r13 = SyntaxNode.new(input, (index-1)...index) if r13 == true
                              r6 = r13
                            else
                              @index = i6
                              r6 = nil
                            end
                          end
                        end
                      end
                    end
                  end
                end
                if r6
                  r5 = r6
                else
                  r5 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                  if r14
                    if (match_len = has_terminal?(';', false, index))
                      r15 = true
                      @index += match_len
                    else
                      terminal_parse_failure('\';\'')
                      r15 = nil
                    end
                    s0 << r15
                    if r15
                      r16 = _nt_s
                      s0 << r16
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(PeriodDef0)
          r0.extend(PeriodDef1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:period_def][start_index] = r0

        r0
      end

      module TrstPortDef0
        def s1
          elements[1]
        end

        def attrs
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module TrstPortDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def d
          elements[4]
        end

        def s2
          elements[5]
        end
      end

      module TrstPortDef2
        def to_ast
          if d.respond_to?(:items)
            n :trstPort_def, name.to_ast, *d.attrs.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :trstPort_def, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_trstPort_def
        start_index = index
        if node_cache[:trstPort_def].has_key?(index)
          cached = node_cache[:trstPort_def][index]
          if cached
            node_cache[:trstPort_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('TRSTPort', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'TRSTPort\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_trstPort_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i7, s7 = index, []
                  if (match_len = has_terminal?('{', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'{\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      s10, i10 = [], index
                      loop do
                        r11 = _nt_attribute_def
                        if r11
                          s10 << r11
                        else
                          break
                        end
                      end
                      r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                      s7 << r10
                      if r10
                        r12 = _nt_s
                        s7 << r12
                        if r12
                          if (match_len = has_terminal?('}', false, index))
                            r13 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'}\'')
                            r13 = nil
                          end
                          s7 << r13
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(TrstPortDef0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(TrstPortDef1)
          r0.extend(TrstPortDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:trstPort_def][start_index] = r0

        r0
      end

      module ToTrstPortDef0
        def s1
          elements[1]
        end

        def items
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module ToTrstPortDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def d
          elements[4]
        end

        def s2
          elements[5]
        end
      end

      module ToTrstPortDef2
        def to_ast
          if d.respond_to?(:items)
            n :toTrstPort_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :toTrstPort_def, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_toTrstPort_def
        start_index = index
        if node_cache[:toTrstPort_def].has_key?(index)
          cached = node_cache[:toTrstPort_def][index]
          if cached
            node_cache[:toTrstPort_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ToTRSTPort', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ToTRSTPort\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_toTrstPort_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i7, s7 = index, []
                  if (match_len = has_terminal?('{', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'{\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      s10, i10 = [], index
                      loop do
                        r11 = _nt_toTrstPort_item
                        if r11
                          s10 << r11
                        else
                          break
                        end
                      end
                      if s10.empty?
                        @index = i10
                        r10 = nil
                      else
                        r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                      end
                      s7 << r10
                      if r10
                        r12 = _nt_s
                        s7 << r12
                        if r12
                          if (match_len = has_terminal?('}', false, index))
                            r13 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'}\'')
                            r13 = nil
                          end
                          s7 << r13
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(ToTrstPortDef0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ToTrstPortDef1)
          r0.extend(ToTrstPortDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:toTrstPort_def][start_index] = r0

        r0
      end

      def _nt_toTrstPort_item
        start_index = index
        if node_cache[:toTrstPort_item].has_key?(index)
          cached = node_cache[:toTrstPort_item][index]
          if cached
            node_cache[:toTrstPort_item][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_attribute_def
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_toTrstPort_source
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:toTrstPort_item][start_index] = r0

        r0
      end

      module ToTrstPortSource0
        def S
          elements[1]
        end

        def signal
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module ToTrstPortSource1
        def to_ast
          n :source, signal.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_toTrstPort_source
        start_index = index
        if node_cache[:toTrstPort_source].has_key?(index)
          cached = node_cache[:toTrstPort_source][index]
          if cached
            node_cache[:toTrstPort_source][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('Source', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'Source\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_concat_trst_signal
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ToTrstPortSource0)
          r0.extend(ToTrstPortSource1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:toTrstPort_source][start_index] = r0

        r0
      end

      module AddressPortDef0
        def s1
          elements[1]
        end

        def attrs
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module AddressPortDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def d
          elements[4]
        end

        def s2
          elements[5]
        end
      end

      module AddressPortDef2
        def to_ast
          if d.respond_to?(:attrs)
            n :addressPort_def, name.to_ast, *d.attrs.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :addressPort_def, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_addressPort_def
        start_index = index
        if node_cache[:addressPort_def].has_key?(index)
          cached = node_cache[:addressPort_def][index]
          if cached
            node_cache[:addressPort_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('AddressPort', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'AddressPort\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_addressPort_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i7, s7 = index, []
                  if (match_len = has_terminal?('{', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'{\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      s10, i10 = [], index
                      loop do
                        r11 = _nt_attribute_def
                        if r11
                          s10 << r11
                        else
                          break
                        end
                      end
                      r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                      s7 << r10
                      if r10
                        r12 = _nt_s
                        s7 << r12
                        if r12
                          if (match_len = has_terminal?('}', false, index))
                            r13 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'}\'')
                            r13 = nil
                          end
                          s7 << r13
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(AddressPortDef0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AddressPortDef1)
          r0.extend(AddressPortDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:addressPort_def][start_index] = r0

        r0
      end

      module WriteEnPortDef0
        def s1
          elements[1]
        end

        def attrs
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module WriteEnPortDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def d
          elements[4]
        end

        def s2
          elements[5]
        end
      end

      module WriteEnPortDef2
        def to_ast
          if d.respond_to?(:attrs)
            n :writeEnPort_def, name.to_ast, *d.attrs.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :writeEnPort_def, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_writeEnPort_def
        start_index = index
        if node_cache[:writeEnPort_def].has_key?(index)
          cached = node_cache[:writeEnPort_def][index]
          if cached
            node_cache[:writeEnPort_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('WriteEnPort', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'WriteEnPort\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_writeEnPort_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i7, s7 = index, []
                  if (match_len = has_terminal?('{', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'{\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      s10, i10 = [], index
                      loop do
                        r11 = _nt_attribute_def
                        if r11
                          s10 << r11
                        else
                          break
                        end
                      end
                      r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                      s7 << r10
                      if r10
                        r12 = _nt_s
                        s7 << r12
                        if r12
                          if (match_len = has_terminal?('}', false, index))
                            r13 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'}\'')
                            r13 = nil
                          end
                          s7 << r13
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(WriteEnPortDef0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(WriteEnPortDef1)
          r0.extend(WriteEnPortDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:writeEnPort_def][start_index] = r0

        r0
      end

      module ReadEnPortDef0
        def s1
          elements[1]
        end

        def attrs
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module ReadEnPortDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def d
          elements[4]
        end

        def s2
          elements[5]
        end
      end

      module ReadEnPortDef2
        def to_ast
          if d.respond_to?(:attrs)
            n :readEnPort_def, name.to_ast, *d.attrs.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :readEnPort_def, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_readEnPort_def
        start_index = index
        if node_cache[:readEnPort_def].has_key?(index)
          cached = node_cache[:readEnPort_def][index]
          if cached
            node_cache[:readEnPort_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ReadEnPort', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ReadEnPort\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_readEnPort_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i7, s7 = index, []
                  if (match_len = has_terminal?('{', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'{\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      s10, i10 = [], index
                      loop do
                        r11 = _nt_attribute_def
                        if r11
                          s10 << r11
                        else
                          break
                        end
                      end
                      r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                      s7 << r10
                      if r10
                        r12 = _nt_s
                        s7 << r12
                        if r12
                          if (match_len = has_terminal?('}', false, index))
                            r13 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'}\'')
                            r13 = nil
                          end
                          s7 << r13
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(ReadEnPortDef0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ReadEnPortDef1)
          r0.extend(ReadEnPortDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:readEnPort_def][start_index] = r0

        r0
      end

      module InstanceDef0
      end

      module InstanceDef1
        def module_name
          elements[1]
        end
      end

      module InstanceDef2
        def s1
          elements[1]
        end

        def items
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module InstanceDef3
        def S1
          elements[1]
        end

        def name
          elements[2]
        end

        def S2
          elements[3]
        end

        def S3
          elements[5]
        end

        def mod
          elements[6]
        end

        def s1
          elements[7]
        end

        def d
          elements[8]
        end

        def s2
          elements[9]
        end
      end

      module InstanceDef4
        def to_ast
          if d.respond_to?(:items)
            n :instance_def, name.to_ast, n(:module_name, mod.text_value), *d.items.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :instance_def, name.to_ast, n(:module_name, mod.text_value), input: input, interval: interval, file: file
          end
        end
      end

      def _nt_instance_def
        start_index = index
        if node_cache[:instance_def].has_key?(index)
          cached = node_cache[:instance_def][index]
          if cached
            node_cache[:instance_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('Instance', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'Instance\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_instance_name
            s0 << r3
            if r3
              r4 = _nt_S
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?('Of', false, index))
                  r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('\'Of\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  if (match_len = has_terminal?('of', false, index))
                    r7 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('\'of\'')
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r8 = _nt_S
                  s0 << r8
                  if r8
                    i9, s9 = index, []
                    i11, s11 = index, []
                    r13 = _nt_namespace_name
                    if r13
                      r12 = r13
                    else
                      r12 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s11 << r12
                    if r12
                      if (match_len = has_terminal?('::', false, index))
                        r14 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                        @index += match_len
                      else
                        terminal_parse_failure('\'::\'')
                        r14 = nil
                      end
                      s11 << r14
                    end
                    if s11.last
                      r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
                      r11.extend(InstanceDef0)
                    else
                      @index = i11
                      r11 = nil
                    end
                    if r11
                      r10 = r11
                    else
                      r10 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s9 << r10
                    if r10
                      r15 = _nt_module_name
                      s9 << r15
                    end
                    if s9.last
                      r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
                      r9.extend(InstanceDef1)
                    else
                      @index = i9
                      r9 = nil
                    end
                    s0 << r9
                    if r9
                      r16 = _nt_s
                      s0 << r16
                      if r16
                        i17 = index
                        if (match_len = has_terminal?(';', false, index))
                          r18 = true
                          @index += match_len
                        else
                          terminal_parse_failure('\';\'')
                          r18 = nil
                        end
                        if r18
                          r18 = SyntaxNode.new(input, (index-1)...index) if r18 == true
                          r17 = r18
                        else
                          i19, s19 = index, []
                          if (match_len = has_terminal?('{', false, index))
                            r20 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'{\'')
                            r20 = nil
                          end
                          s19 << r20
                          if r20
                            r21 = _nt_s
                            s19 << r21
                            if r21
                              s22, i22 = [], index
                              loop do
                                r23 = _nt_instance_item
                                if r23
                                  s22 << r23
                                else
                                  break
                                end
                              end
                              r22 = instantiate_node(SyntaxNode,input, i22...index, s22)
                              s19 << r22
                              if r22
                                r24 = _nt_s
                                s19 << r24
                                if r24
                                  if (match_len = has_terminal?('}', false, index))
                                    r25 = true
                                    @index += match_len
                                  else
                                    terminal_parse_failure('\'}\'')
                                    r25 = nil
                                  end
                                  s19 << r25
                                end
                              end
                            end
                          end
                          if s19.last
                            r19 = instantiate_node(SyntaxNode,input, i19...index, s19)
                            r19.extend(InstanceDef2)
                          else
                            @index = i19
                            r19 = nil
                          end
                          if r19
                            r19 = SyntaxNode.new(input, (index-1)...index) if r19 == true
                            r17 = r19
                          else
                            @index = i17
                            r17 = nil
                          end
                        end
                        s0 << r17
                        if r17
                          r26 = _nt_s
                          s0 << r26
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(InstanceDef3)
          r0.extend(InstanceDef4)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:instance_def][start_index] = r0

        r0
      end

      def _nt_instance_item
        start_index = index
        if node_cache[:instance_item].has_key?(index)
          cached = node_cache[:instance_item][index]
          if cached
            node_cache[:instance_item][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_inputPort_connection
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_allowBroadcast_def
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_attribute_def
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              r4 = _nt_parameter_override
              if r4
                r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
                r0 = r4
              else
                r5 = _nt_instance_addressValue
                if r5
                  r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                  r0 = r5
                else
                  @index = i0
                  r0 = nil
                end
              end
            end
          end
        end

        node_cache[:instance_item][start_index] = r0

        r0
      end

      module InputPortConnection0
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end

        def source
          elements[6]
        end

        def s3
          elements[7]
        end

        def s4
          elements[9]
        end
      end

      module InputPortConnection1
        def to_ast
          n :inputPort_connection, name.to_ast, source.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_inputPort_connection
        start_index = index
        if node_cache[:inputPort_connection].has_key?(index)
          cached = node_cache[:inputPort_connection][index]
          if cached
            node_cache[:inputPort_connection][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('InputPort', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'InputPort\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_inputPort_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?('=', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\'=\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                  if r6
                    r7 = _nt_inputPort_source
                    s0 << r7
                    if r7
                      r8 = _nt_s
                      s0 << r8
                      if r8
                        if (match_len = has_terminal?(';', false, index))
                          r9 = true
                          @index += match_len
                        else
                          terminal_parse_failure('\';\'')
                          r9 = nil
                        end
                        s0 << r9
                        if r9
                          r10 = _nt_s
                          s0 << r10
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(InputPortConnection0)
          r0.extend(InputPortConnection1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:inputPort_connection][start_index] = r0

        r0
      end

      module AllowBroadcastDef0
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module AllowBroadcastDef1
        def to_ast
          n :allowBroadcast_def, name.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_allowBroadcast_def
        start_index = index
        if node_cache[:allowBroadcast_def].has_key?(index)
          cached = node_cache[:allowBroadcast_def][index]
          if cached
            node_cache[:allowBroadcast_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('AllowBroadcastOnScanInterface', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'AllowBroadcastOnScanInterface\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_scanInterface_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AllowBroadcastDef0)
          r0.extend(AllowBroadcastDef1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:allowBroadcast_def][start_index] = r0

        r0
      end

      def _nt_inputPort_source
        start_index = index
        if node_cache[:inputPort_source].has_key?(index)
          cached = node_cache[:inputPort_source][index]
          if cached
            node_cache[:inputPort_source][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_concat_reset_signal
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_concat_scan_signal
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_concat_data_signal
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              r4 = _nt_concat_clock_signal
              if r4
                r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
                r0 = r4
              else
                r5 = _nt_concat_tck_signal
                if r5
                  r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                  r0 = r5
                else
                  r6 = _nt_concat_shiftEn_signal
                  if r6
                    r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                    r0 = r6
                  else
                    r7 = _nt_concat_captureEn_signal
                    if r7
                      r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                      r0 = r7
                    else
                      r8 = _nt_concat_updateEn_signal
                      if r8
                        r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
                        r0 = r8
                      else
                        r9 = _nt_concat_tms_signal
                        if r9
                          r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
                          r0 = r9
                        else
                          r10 = _nt_concat_trst_signal
                          if r10
                            r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                            r0 = r10
                          else
                            @index = i0
                            r0 = nil
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end

        node_cache[:inputPort_source][start_index] = r0

        r0
      end

      module InstanceAddressValue0
        def S
          elements[1]
        end

        def val
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module InstanceAddressValue1
        def to_ast
          n :instance_addressValue, val.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_instance_addressValue
        start_index = index
        if node_cache[:instance_addressValue].has_key?(index)
          cached = node_cache[:instance_addressValue][index]
          if cached
            node_cache[:instance_addressValue][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('AddressValue', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'AddressValue\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_number
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(InstanceAddressValue0)
          r0.extend(InstanceAddressValue1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:instance_addressValue][start_index] = r0

        r0
      end

      module ScanRegisterDef0
        def s1
          elements[1]
        end

        def items
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module ScanRegisterDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def d
          elements[4]
        end

        def s2
          elements[5]
        end
      end

      module ScanRegisterDef2
        def to_ast
          if d.respond_to?(:items)
            n :scanRegister_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :scanRegister_def, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_scanRegister_def
        start_index = index
        if node_cache[:scanRegister_def].has_key?(index)
          cached = node_cache[:scanRegister_def][index]
          if cached
            node_cache[:scanRegister_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ScanRegister', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ScanRegister\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_scanRegister_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i7, s7 = index, []
                  if (match_len = has_terminal?('{', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'{\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      s10, i10 = [], index
                      loop do
                        r11 = _nt_scanRegister_item
                        if r11
                          s10 << r11
                        else
                          break
                        end
                      end
                      r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                      s7 << r10
                      if r10
                        r12 = _nt_s
                        s7 << r12
                        if r12
                          if (match_len = has_terminal?('}', false, index))
                            r13 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'}\'')
                            r13 = nil
                          end
                          s7 << r13
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(ScanRegisterDef0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ScanRegisterDef1)
          r0.extend(ScanRegisterDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:scanRegister_def][start_index] = r0

        r0
      end

      def _nt_scanRegister_item
        start_index = index
        if node_cache[:scanRegister_item].has_key?(index)
          cached = node_cache[:scanRegister_item][index]
          if cached
            node_cache[:scanRegister_item][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_attribute_def
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_scanRegister_scanInSource
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_scanRegister_defaultLoadValue
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              r4 = _nt_scanRegister_captureSource
              if r4
                r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
                r0 = r4
              else
                r5 = _nt_scanRegister_resetValue
                if r5
                  r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                  r0 = r5
                else
                  r6 = _nt_scanRegister_refEnum
                  if r6
                    r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                    r0 = r6
                  else
                    @index = i0
                    r0 = nil
                  end
                end
              end
            end
          end
        end

        node_cache[:scanRegister_item][start_index] = r0

        r0
      end

      module ScanRegisterScanInSource0
        def S
          elements[1]
        end

        def signal
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module ScanRegisterScanInSource1
        def to_ast
          n :scanInSource, signal.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_scanRegister_scanInSource
        start_index = index
        if node_cache[:scanRegister_scanInSource].has_key?(index)
          cached = node_cache[:scanRegister_scanInSource][index]
          if cached
            node_cache[:scanRegister_scanInSource][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ScanInSource', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ScanInSource\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_scan_signal
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ScanRegisterScanInSource0)
          r0.extend(ScanRegisterScanInSource1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:scanRegister_scanInSource][start_index] = r0

        r0
      end

      module ScanRegisterDefaultLoadValue0
        def S
          elements[1]
        end

        def val
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module ScanRegisterDefaultLoadValue1
        def to_ast
          n :defaultLoadValue, val.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_scanRegister_defaultLoadValue
        start_index = index
        if node_cache[:scanRegister_defaultLoadValue].has_key?(index)
          cached = node_cache[:scanRegister_defaultLoadValue][index]
          if cached
            node_cache[:scanRegister_defaultLoadValue][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('DefaultLoadValue', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'DefaultLoadValue\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            i3 = index
            r4 = _nt_concat_number
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r3 = r4
            else
              r5 = _nt_enum_symbol
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r3 = r5
              else
                @index = i3
                r3 = nil
              end
            end
            s0 << r3
            if r3
              r6 = _nt_s
              s0 << r6
              if r6
                if (match_len = has_terminal?(';', false, index))
                  r7 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r7 = nil
                end
                s0 << r7
                if r7
                  r8 = _nt_s
                  s0 << r8
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ScanRegisterDefaultLoadValue0)
          r0.extend(ScanRegisterDefaultLoadValue1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:scanRegister_defaultLoadValue][start_index] = r0

        r0
      end

      module ScanRegisterCaptureSource0
        def S
          elements[1]
        end

        def source
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module ScanRegisterCaptureSource1
        def to_ast
          n :captureSource, source.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_scanRegister_captureSource
        start_index = index
        if node_cache[:scanRegister_captureSource].has_key?(index)
          cached = node_cache[:scanRegister_captureSource][index]
          if cached
            node_cache[:scanRegister_captureSource][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('CaptureSource', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'CaptureSource\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            i3 = index
            r4 = _nt_concat_data_signal
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r3 = r4
            else
              r5 = _nt_enum_symbol
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r3 = r5
              else
                @index = i3
                r3 = nil
              end
            end
            s0 << r3
            if r3
              r6 = _nt_s
              s0 << r6
              if r6
                if (match_len = has_terminal?(';', false, index))
                  r7 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r7 = nil
                end
                s0 << r7
                if r7
                  r8 = _nt_s
                  s0 << r8
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ScanRegisterCaptureSource0)
          r0.extend(ScanRegisterCaptureSource1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:scanRegister_captureSource][start_index] = r0

        r0
      end

      module ScanRegisterResetValue0
        def S
          elements[1]
        end

        def val
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module ScanRegisterResetValue1
        def to_ast
          n :resetValue, val.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_scanRegister_resetValue
        start_index = index
        if node_cache[:scanRegister_resetValue].has_key?(index)
          cached = node_cache[:scanRegister_resetValue][index]
          if cached
            node_cache[:scanRegister_resetValue][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ResetValue', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ResetValue\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            i3 = index
            r4 = _nt_concat_number
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r3 = r4
            else
              r5 = _nt_enum_symbol
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r3 = r5
              else
                @index = i3
                r3 = nil
              end
            end
            s0 << r3
            if r3
              r6 = _nt_s
              s0 << r6
              if r6
                if (match_len = has_terminal?(';', false, index))
                  r7 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r7 = nil
                end
                s0 << r7
                if r7
                  r8 = _nt_s
                  s0 << r8
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ScanRegisterResetValue0)
          r0.extend(ScanRegisterResetValue1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:scanRegister_resetValue][start_index] = r0

        r0
      end

      module ScanRegisterRefEnum0
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module ScanRegisterRefEnum1
        def to_ast
          n :refEnum, name.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_scanRegister_refEnum
        start_index = index
        if node_cache[:scanRegister_refEnum].has_key?(index)
          cached = node_cache[:scanRegister_refEnum][index]
          if cached
            node_cache[:scanRegister_refEnum][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('RefEnum', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'RefEnum\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_enum_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ScanRegisterRefEnum0)
          r0.extend(ScanRegisterRefEnum1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:scanRegister_refEnum][start_index] = r0

        r0
      end

      module DataRegisterDef0
        def s1
          elements[1]
        end

        def items
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      module DataRegisterDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def d
          elements[4]
        end

        def s2
          elements[5]
        end
      end

      module DataRegisterDef2
        def to_ast
          if d.respond_to?(:items)
            n :dataRegister_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :dataRegister_def, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_dataRegister_def
        start_index = index
        if node_cache[:dataRegister_def].has_key?(index)
          cached = node_cache[:dataRegister_def][index]
          if cached
            node_cache[:dataRegister_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('DataRegister', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'DataRegister\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_dataRegister_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i7, s7 = index, []
                  if (match_len = has_terminal?('{', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'{\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      s10, i10 = [], index
                      loop do
                        r11 = _nt_dataRegister_item
                        if r11
                          s10 << r11
                        else
                          break
                        end
                      end
                      if s10.empty?
                        @index = i10
                        r10 = nil
                      else
                        r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                      end
                      s7 << r10
                      if r10
                        r12 = _nt_s
                        s7 << r12
                        if r12
                          if (match_len = has_terminal?('}', false, index))
                            r13 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'}\'')
                            r13 = nil
                          end
                          s7 << r13
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(DataRegisterDef0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r14 = _nt_s
                  s0 << r14
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DataRegisterDef1)
          r0.extend(DataRegisterDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:dataRegister_def][start_index] = r0

        r0
      end

      def _nt_dataRegister_item
        start_index = index
        if node_cache[:dataRegister_item].has_key?(index)
          cached = node_cache[:dataRegister_item][index]
          if cached
            node_cache[:dataRegister_item][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_dataRegister_type
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_dataRegister_common
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:dataRegister_item][start_index] = r0

        r0
      end

      def _nt_dataRegister_type
        start_index = index
        if node_cache[:dataRegister_type].has_key?(index)
          cached = node_cache[:dataRegister_type][index]
          if cached
            node_cache[:dataRegister_type][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_dataRegister_selectable
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_dataRegister_addressable
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_dataRegister_readCallBack
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              r4 = _nt_dataRegister_writeCallBack
              if r4
                r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
                r0 = r4
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end

        node_cache[:dataRegister_type][start_index] = r0

        r0
      end

      def _nt_dataRegister_common
        start_index = index
        if node_cache[:dataRegister_common].has_key?(index)
          cached = node_cache[:dataRegister_common][index]
          if cached
            node_cache[:dataRegister_common][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_dataRegister_resetValue
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_dataRegister_defaultLoadValue
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_dataRegister_refEnum
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              r4 = _nt_attribute_def
              if r4
                r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
                r0 = r4
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end

        node_cache[:dataRegister_common][start_index] = r0

        r0
      end

      module DataRegisterResetValue0
        def S
          elements[1]
        end

        def val
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module DataRegisterResetValue1
        def to_ast
          n :resetValue, val.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_dataRegister_resetValue
        start_index = index
        if node_cache[:dataRegister_resetValue].has_key?(index)
          cached = node_cache[:dataRegister_resetValue][index]
          if cached
            node_cache[:dataRegister_resetValue][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ResetValue', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ResetValue\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            i3 = index
            r4 = _nt_concat_number
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r3 = r4
            else
              r5 = _nt_enum_symbol
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r3 = r5
              else
                @index = i3
                r3 = nil
              end
            end
            s0 << r3
            if r3
              r6 = _nt_s
              s0 << r6
              if r6
                if (match_len = has_terminal?(';', false, index))
                  r7 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r7 = nil
                end
                s0 << r7
                if r7
                  r8 = _nt_s
                  s0 << r8
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DataRegisterResetValue0)
          r0.extend(DataRegisterResetValue1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:dataRegister_resetValue][start_index] = r0

        r0
      end

      module DataRegisterDefaultLoadValue0
        def S
          elements[1]
        end

        def val
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module DataRegisterDefaultLoadValue1
        def to_ast
          n :defaultLoadValue, val.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_dataRegister_defaultLoadValue
        start_index = index
        if node_cache[:dataRegister_defaultLoadValue].has_key?(index)
          cached = node_cache[:dataRegister_defaultLoadValue][index]
          if cached
            node_cache[:dataRegister_defaultLoadValue][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('DefaultLoadValue', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'DefaultLoadValue\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            i3 = index
            r4 = _nt_concat_number
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r3 = r4
            else
              r5 = _nt_enum_symbol
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r3 = r5
              else
                @index = i3
                r3 = nil
              end
            end
            s0 << r3
            if r3
              r6 = _nt_s
              s0 << r6
              if r6
                if (match_len = has_terminal?(';', false, index))
                  r7 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r7 = nil
                end
                s0 << r7
                if r7
                  r8 = _nt_s
                  s0 << r8
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DataRegisterDefaultLoadValue0)
          r0.extend(DataRegisterDefaultLoadValue1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:dataRegister_defaultLoadValue][start_index] = r0

        r0
      end

      module DataRegisterRefEnum0
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module DataRegisterRefEnum1
        def to_ast
          n :refEnum, name.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_dataRegister_refEnum
        start_index = index
        if node_cache[:dataRegister_refEnum].has_key?(index)
          cached = node_cache[:dataRegister_refEnum][index]
          if cached
            node_cache[:dataRegister_refEnum][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('RefEnum', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'RefEnum\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_enum_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DataRegisterRefEnum0)
          r0.extend(DataRegisterRefEnum1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:dataRegister_refEnum][start_index] = r0

        r0
      end

      def _nt_dataRegister_selectable
        start_index = index
        if node_cache[:dataRegister_selectable].has_key?(index)
          cached = node_cache[:dataRegister_selectable][index]
          if cached
            node_cache[:dataRegister_selectable][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_dataRegister_writeEnSource
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_dataRegister_writeDataSource
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:dataRegister_selectable][start_index] = r0

        r0
      end

      module DataRegisterWriteEnSource0
        def S
          elements[1]
        end

        def signal
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module DataRegisterWriteEnSource1
        def to_ast
          n :dataRegister_writeEnSource, signal.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_dataRegister_writeEnSource
        start_index = index
        if node_cache[:dataRegister_writeEnSource].has_key?(index)
          cached = node_cache[:dataRegister_writeEnSource][index]
          if cached
            node_cache[:dataRegister_writeEnSource][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('WriteEnSource', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'WriteEnSource\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_data_signal
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DataRegisterWriteEnSource0)
          r0.extend(DataRegisterWriteEnSource1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:dataRegister_writeEnSource][start_index] = r0

        r0
      end

      module DataRegisterWriteDataSource0
        def S
          elements[1]
        end

        def signal
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module DataRegisterWriteDataSource1
        def to_ast
          n :dataRegister_writeDataSource, signal.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_dataRegister_writeDataSource
        start_index = index
        if node_cache[:dataRegister_writeDataSource].has_key?(index)
          cached = node_cache[:dataRegister_writeDataSource][index]
          if cached
            node_cache[:dataRegister_writeDataSource][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('WriteDataSource', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'WriteDataSource\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_concat_data_signal
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DataRegisterWriteDataSource0)
          r0.extend(DataRegisterWriteDataSource1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:dataRegister_writeDataSource][start_index] = r0

        r0
      end

      module DataRegisterAddressValue0
        def S
          elements[1]
        end

        def val
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module DataRegisterAddressValue1
        def to_ast
          n :dataRegister_addressValue, val.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_dataRegister_addressValue
        start_index = index
        if node_cache[:dataRegister_addressValue].has_key?(index)
          cached = node_cache[:dataRegister_addressValue][index]
          if cached
            node_cache[:dataRegister_addressValue][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('AddressValue', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'AddressValue\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_number
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DataRegisterAddressValue0)
          r0.extend(DataRegisterAddressValue1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:dataRegister_addressValue][start_index] = r0

        r0
      end

      def _nt_dataRegister_readCallBack
        start_index = index
        if node_cache[:dataRegister_readCallBack].has_key?(index)
          cached = node_cache[:dataRegister_readCallBack][index]
          if cached
            node_cache[:dataRegister_readCallBack][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_dataRegister_readCallBack_proc
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_dataRegister_readDataSource
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:dataRegister_readCallBack][start_index] = r0

        r0
      end

      module DataRegisterReadCallBackProc0
        def S1
          elements[1]
        end

        def namespace
          elements[2]
        end

        def S2
          elements[3]
        end

        def name
          elements[4]
        end

        def s1
          elements[5]
        end

        def args
          elements[6]
        end

        def s2
          elements[7]
        end

        def s3
          elements[9]
        end
      end

      module DataRegisterReadCallBackProc1
        def to_ast
          if respond_to?(:args)
            n :dataRegister_readCallBack_proc, namespace.to_ast, name.to_ast, *args.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :dataRegister_readCallBack_proc, namespace.to_ast, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_dataRegister_readCallBack_proc
        start_index = index
        if node_cache[:dataRegister_readCallBack_proc].has_key?(index)
          cached = node_cache[:dataRegister_readCallBack_proc][index]
          if cached
            node_cache[:dataRegister_readCallBack_proc][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ReadCallBack', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ReadCallBack\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_iProc_namespace
            s0 << r3
            if r3
              r4 = _nt_S
              s0 << r4
              if r4
                r5 = _nt_iProc_name
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                  if r6
                    s7, i7 = [], index
                    loop do
                      r8 = _nt_iProc_args
                      if r8
                        s7 << r8
                      else
                        break
                      end
                    end
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    s0 << r7
                    if r7
                      r9 = _nt_s
                      s0 << r9
                      if r9
                        if (match_len = has_terminal?(';', false, index))
                          r10 = true
                          @index += match_len
                        else
                          terminal_parse_failure('\';\'')
                          r10 = nil
                        end
                        s0 << r10
                        if r10
                          r11 = _nt_s
                          s0 << r11
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DataRegisterReadCallBackProc0)
          r0.extend(DataRegisterReadCallBackProc1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:dataRegister_readCallBack_proc][start_index] = r0

        r0
      end

      module DataRegisterReadDataSource0
        def S
          elements[1]
        end

        def signal
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module DataRegisterReadDataSource1
        def to_ast
          n :dataRegister_readDataSource, signal.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_dataRegister_readDataSource
        start_index = index
        if node_cache[:dataRegister_readDataSource].has_key?(index)
          cached = node_cache[:dataRegister_readDataSource][index]
          if cached
            node_cache[:dataRegister_readDataSource][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ReadDataSource', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ReadDataSource\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_concat_data_signal
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DataRegisterReadDataSource0)
          r0.extend(DataRegisterReadDataSource1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:dataRegister_readDataSource][start_index] = r0

        r0
      end

      module DataRegisterWriteCallBack0
        def S1
          elements[1]
        end

        def namespace
          elements[2]
        end

        def S2
          elements[3]
        end

        def name
          elements[4]
        end

        def s1
          elements[5]
        end

        def args
          elements[6]
        end

        def s2
          elements[7]
        end

        def s3
          elements[9]
        end
      end

      module DataRegisterWriteCallBack1
        def to_ast
          if respond_to?(:args)
            n :dataRegister_writeCallBack, namespace.to_ast, name.to_ast, *args.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :dataRegister_writeCallBack, namespace.to_ast, name.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_dataRegister_writeCallBack
        start_index = index
        if node_cache[:dataRegister_writeCallBack].has_key?(index)
          cached = node_cache[:dataRegister_writeCallBack][index]
          if cached
            node_cache[:dataRegister_writeCallBack][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('WriteCallBack', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'WriteCallBack\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_iProc_namespace
            s0 << r3
            if r3
              r4 = _nt_S
              s0 << r4
              if r4
                r5 = _nt_iProc_name
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                  if r6
                    s7, i7 = [], index
                    loop do
                      r8 = _nt_iProc_args
                      if r8
                        s7 << r8
                      else
                        break
                      end
                    end
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    s0 << r7
                    if r7
                      r9 = _nt_s
                      s0 << r9
                      if r9
                        if (match_len = has_terminal?(';', false, index))
                          r10 = true
                          @index += match_len
                        else
                          terminal_parse_failure('\';\'')
                          r10 = nil
                        end
                        s0 << r10
                        if r10
                          r11 = _nt_s
                          s0 << r11
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DataRegisterWriteCallBack0)
          r0.extend(DataRegisterWriteCallBack1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:dataRegister_writeCallBack][start_index] = r0

        r0
      end

      module IProcNamespace0
      end

      module IProcNamespace1
        def sub_namespace
          elements[1]
        end
      end

      module IProcNamespace2
        def ref_module_name
          elements[1]
        end

        def s
          elements[3]
        end
      end

      module IProcNamespace3
        def to_ast
          n :iProc_namespace, text_value, input: input, interval: interval, file: file
        end
      end

      def _nt_iProc_namespace
        start_index = index
        if node_cache[:iProc_namespace].has_key?(index)
          cached = node_cache[:iProc_namespace][index]
          if cached
            node_cache[:iProc_namespace][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i2, s2 = index, []
        r4 = _nt_namespace_name
        if r4
          r3 = r4
        else
          r3 = instantiate_node(SyntaxNode,input, index...index)
        end
        s2 << r3
        if r3
          if (match_len = has_terminal?('::', false, index))
            r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'::\'')
            r5 = nil
          end
          s2 << r5
        end
        if s2.last
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          r2.extend(IProcNamespace0)
        else
          @index = i2
          r2 = nil
        end
        if r2
          r1 = r2
        else
          r1 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r1
        if r1
          r6 = _nt_ref_module_name
          s0 << r6
          if r6
            i8, s8 = index, []
            if (match_len = has_terminal?('::', false, index))
              r9 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('\'::\'')
              r9 = nil
            end
            s8 << r9
            if r9
              r10 = _nt_sub_namespace
              s8 << r10
            end
            if s8.last
              r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
              r8.extend(IProcNamespace1)
            else
              @index = i8
              r8 = nil
            end
            if r8
              r7 = r8
            else
              r7 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r7
            if r7
              r11 = _nt_s
              s0 << r11
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(IProcNamespace2)
          r0.extend(IProcNamespace3)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:iProc_namespace][start_index] = r0

        r0
      end

      def _nt_iProc_name
        start_index = index
        if node_cache[:iProc_name].has_key?(index)
          cached = node_cache[:iProc_name][index]
          if cached
            node_cache[:iProc_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_parameter_ref
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_SCALAR_ID
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:iProc_name][start_index] = r0

        r0
      end

      def _nt_iProc_args
        start_index = index
        if node_cache[:iProc_args].has_key?(index)
          cached = node_cache[:iProc_args][index]
          if cached
            node_cache[:iProc_args][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_parameter_ref
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          if (match_len = has_terminal?('<D>', false, index))
            r2 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'<D>\'')
            r2 = nil
          end
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            if (match_len = has_terminal?('<R>', false, index))
              r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('\'<R>\'')
              r3 = nil
            end
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              r4 = _nt_number
              if r4
                r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
                r0 = r4
              else
                r5 = _nt_STRING
                if r5
                  r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                  r0 = r5
                else
                  @index = i0
                  r0 = nil
                end
              end
            end
          end
        end

        node_cache[:iProc_args][start_index] = r0

        r0
      end

      def _nt_sub_namespace
        start_index = index
        if node_cache[:sub_namespace].has_key?(index)
          cached = node_cache[:sub_namespace][index]
          if cached
            node_cache[:sub_namespace][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_parameter_ref
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_SCALAR_ID
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:sub_namespace][start_index] = r0

        r0
      end

      def _nt_ref_module_name
        start_index = index
        if node_cache[:ref_module_name].has_key?(index)
          cached = node_cache[:ref_module_name][index]
          if cached
            node_cache[:ref_module_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_parameter_ref
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_SCALAR_ID
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:ref_module_name][start_index] = r0

        r0
      end

      module LogicSignalDef0
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end

        def expr
          elements[6]
        end

        def s3
          elements[7]
        end

        def s4
          elements[9]
        end

        def s5
          elements[11]
        end
      end

      module LogicSignalDef1
        def to_ast
          n :logicSignal_def, name.to_ast, expr.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_logicSignal_def
        start_index = index
        if node_cache[:logicSignal_def].has_key?(index)
          cached = node_cache[:logicSignal_def][index]
          if cached
            node_cache[:logicSignal_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('LogicSignal', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'LogicSignal\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_logicSignal_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?('{', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\'{\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                  if r6
                    r7 = _nt_logic_expr
                    s0 << r7
                    if r7
                      r8 = _nt_s
                      s0 << r8
                      if r8
                        if (match_len = has_terminal?(';', false, index))
                          r9 = true
                          @index += match_len
                        else
                          terminal_parse_failure('\';\'')
                          r9 = nil
                        end
                        s0 << r9
                        if r9
                          r10 = _nt_s
                          s0 << r10
                          if r10
                            if (match_len = has_terminal?('}', false, index))
                              r11 = true
                              @index += match_len
                            else
                              terminal_parse_failure('\'}\'')
                              r11 = nil
                            end
                            s0 << r11
                            if r11
                              r12 = _nt_s
                              s0 << r12
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(LogicSignalDef0)
          r0.extend(LogicSignalDef1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:logicSignal_def][start_index] = r0

        r0
      end

      module ScanMuxDef0
        def S1
          elements[1]
        end

        def name
          elements[2]
        end

        def S2
          elements[3]
        end

        def S3
          elements[5]
        end

        def select
          elements[6]
        end

        def s1
          elements[7]
        end

        def s2
          elements[9]
        end

        def selections
          elements[10]
        end

        def s3
          elements[11]
        end

        def s4
          elements[13]
        end
      end

      module ScanMuxDef1
        def to_ast
          n :scanMux_def, name.to_ast, select.to_ast, *selections.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
        end
      end

      def _nt_scanMux_def
        start_index = index
        if node_cache[:scanMux_def].has_key?(index)
          cached = node_cache[:scanMux_def][index]
          if cached
            node_cache[:scanMux_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ScanMux', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ScanMux\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_scanMux_name
            s0 << r3
            if r3
              r4 = _nt_S
              s0 << r4
              if r4
                if (match_len = has_terminal?('SelectedBy', false, index))
                  r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('\'SelectedBy\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_S
                  s0 << r6
                  if r6
                    r7 = _nt_scanMux_select
                    s0 << r7
                    if r7
                      r8 = _nt_s
                      s0 << r8
                      if r8
                        if (match_len = has_terminal?('{', false, index))
                          r9 = true
                          @index += match_len
                        else
                          terminal_parse_failure('\'{\'')
                          r9 = nil
                        end
                        s0 << r9
                        if r9
                          r10 = _nt_s
                          s0 << r10
                          if r10
                            s11, i11 = [], index
                            loop do
                              r12 = _nt_scanMux_selection
                              if r12
                                s11 << r12
                              else
                                break
                              end
                            end
                            if s11.empty?
                              @index = i11
                              r11 = nil
                            else
                              r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
                            end
                            s0 << r11
                            if r11
                              r13 = _nt_s
                              s0 << r13
                              if r13
                                if (match_len = has_terminal?('}', false, index))
                                  r14 = true
                                  @index += match_len
                                else
                                  terminal_parse_failure('\'}\'')
                                  r14 = nil
                                end
                                s0 << r14
                                if r14
                                  r15 = _nt_s
                                  s0 << r15
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ScanMuxDef0)
          r0.extend(ScanMuxDef1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:scanMux_def][start_index] = r0

        r0
      end

      module ScanMuxSelection0
        def concat_number_list
          elements[0]
        end

        def concat_scan_signal
          elements[2]
        end
      end

      module ScanMuxSelection1
        def val
          elements[0]
        end

        def s1
          elements[1]
        end

        def s2
          elements[3]
        end
      end

      module ScanMuxSelection2
        def to_ast
          n :scanMux_selection, val.text_value, input: input, interval: interval, file: file
        end
      end

      def _nt_scanMux_selection
        start_index = index
        if node_cache[:scanMux_selection].has_key?(index)
          cached = node_cache[:scanMux_selection][index]
          if cached
            node_cache[:scanMux_selection][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1, s1 = index, []
        r2 = _nt_concat_number_list
        s1 << r2
        if r2
          if (match_len = has_terminal?(':', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('\':\'')
            r3 = nil
          end
          s1 << r3
          if r3
            r4 = _nt_concat_scan_signal
            s1 << r4
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(ScanMuxSelection0)
        else
          @index = i1
          r1 = nil
        end
        s0 << r1
        if r1
          r5 = _nt_s
          s0 << r5
          if r5
            if (match_len = has_terminal?(';', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('\';\'')
              r6 = nil
            end
            s0 << r6
            if r6
              r7 = _nt_s
              s0 << r7
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ScanMuxSelection1)
          r0.extend(ScanMuxSelection2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:scanMux_selection][start_index] = r0

        r0
      end

      module DataMuxDef0
        def S1
          elements[1]
        end

        def name
          elements[2]
        end

        def S2
          elements[3]
        end

        def S3
          elements[5]
        end

        def select
          elements[6]
        end

        def s1
          elements[7]
        end

        def s2
          elements[9]
        end

        def selections
          elements[10]
        end

        def s3
          elements[11]
        end

        def s4
          elements[13]
        end
      end

      module DataMuxDef1
        def to_ast
          n :dataMux_def, name.to_ast, select.to_ast, *selections.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
        end
      end

      def _nt_dataMux_def
        start_index = index
        if node_cache[:dataMux_def].has_key?(index)
          cached = node_cache[:dataMux_def][index]
          if cached
            node_cache[:dataMux_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('DataMux', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'DataMux\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_dataMux_name
            s0 << r3
            if r3
              r4 = _nt_S
              s0 << r4
              if r4
                if (match_len = has_terminal?('SelectedBy', false, index))
                  r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('\'SelectedBy\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_S
                  s0 << r6
                  if r6
                    r7 = _nt_dataMux_select
                    s0 << r7
                    if r7
                      r8 = _nt_s
                      s0 << r8
                      if r8
                        if (match_len = has_terminal?('{', false, index))
                          r9 = true
                          @index += match_len
                        else
                          terminal_parse_failure('\'{\'')
                          r9 = nil
                        end
                        s0 << r9
                        if r9
                          r10 = _nt_s
                          s0 << r10
                          if r10
                            s11, i11 = [], index
                            loop do
                              r12 = _nt_dataMux_selection
                              if r12
                                s11 << r12
                              else
                                break
                              end
                            end
                            if s11.empty?
                              @index = i11
                              r11 = nil
                            else
                              r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
                            end
                            s0 << r11
                            if r11
                              r13 = _nt_s
                              s0 << r13
                              if r13
                                if (match_len = has_terminal?('}', false, index))
                                  r14 = true
                                  @index += match_len
                                else
                                  terminal_parse_failure('\'}\'')
                                  r14 = nil
                                end
                                s0 << r14
                                if r14
                                  r15 = _nt_s
                                  s0 << r15
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DataMuxDef0)
          r0.extend(DataMuxDef1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:dataMux_def][start_index] = r0

        r0
      end

      module DataMuxSelection0
        def concat_number_list
          elements[0]
        end

        def concat_data_signal
          elements[2]
        end
      end

      module DataMuxSelection1
        def val
          elements[0]
        end

        def s1
          elements[1]
        end

        def s2
          elements[3]
        end
      end

      module DataMuxSelection2
        def to_ast
          n :dataMux_selection, val.text_value, input: input, interval: interval, file: file
        end
      end

      def _nt_dataMux_selection
        start_index = index
        if node_cache[:dataMux_selection].has_key?(index)
          cached = node_cache[:dataMux_selection][index]
          if cached
            node_cache[:dataMux_selection][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1, s1 = index, []
        r2 = _nt_concat_number_list
        s1 << r2
        if r2
          if (match_len = has_terminal?(':', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('\':\'')
            r3 = nil
          end
          s1 << r3
          if r3
            r4 = _nt_concat_data_signal
            s1 << r4
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(DataMuxSelection0)
        else
          @index = i1
          r1 = nil
        end
        s0 << r1
        if r1
          r5 = _nt_s
          s0 << r5
          if r5
            if (match_len = has_terminal?(';', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('\';\'')
              r6 = nil
            end
            s0 << r6
            if r6
              r7 = _nt_s
              s0 << r7
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DataMuxSelection1)
          r0.extend(DataMuxSelection2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:dataMux_selection][start_index] = r0

        r0
      end

      module ClockMuxDef0
        def S1
          elements[1]
        end

        def name
          elements[2]
        end

        def S2
          elements[3]
        end

        def S3
          elements[5]
        end

        def select
          elements[6]
        end

        def s1
          elements[7]
        end

        def s2
          elements[9]
        end

        def selections
          elements[10]
        end

        def s3
          elements[11]
        end

        def s4
          elements[13]
        end
      end

      module ClockMuxDef1
        def to_ast
          n :clockMux_def, name.to_ast, select.to_ast, *selections.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
        end
      end

      def _nt_clockMux_def
        start_index = index
        if node_cache[:clockMux_def].has_key?(index)
          cached = node_cache[:clockMux_def][index]
          if cached
            node_cache[:clockMux_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ClockMux', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ClockMux\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_clockMux_name
            s0 << r3
            if r3
              r4 = _nt_S
              s0 << r4
              if r4
                if (match_len = has_terminal?('SelectedBy', false, index))
                  r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('\'SelectedBy\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_S
                  s0 << r6
                  if r6
                    r7 = _nt_clockMux_select
                    s0 << r7
                    if r7
                      r8 = _nt_s
                      s0 << r8
                      if r8
                        if (match_len = has_terminal?('{', false, index))
                          r9 = true
                          @index += match_len
                        else
                          terminal_parse_failure('\'{\'')
                          r9 = nil
                        end
                        s0 << r9
                        if r9
                          r10 = _nt_s
                          s0 << r10
                          if r10
                            s11, i11 = [], index
                            loop do
                              r12 = _nt_clockMux_selection
                              if r12
                                s11 << r12
                              else
                                break
                              end
                            end
                            if s11.empty?
                              @index = i11
                              r11 = nil
                            else
                              r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
                            end
                            s0 << r11
                            if r11
                              r13 = _nt_s
                              s0 << r13
                              if r13
                                if (match_len = has_terminal?('}', false, index))
                                  r14 = true
                                  @index += match_len
                                else
                                  terminal_parse_failure('\'}\'')
                                  r14 = nil
                                end
                                s0 << r14
                                if r14
                                  r15 = _nt_s
                                  s0 << r15
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ClockMuxDef0)
          r0.extend(ClockMuxDef1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:clockMux_def][start_index] = r0

        r0
      end

      module ClockMuxSelection0
        def concat_number_list
          elements[0]
        end

        def concat_clock_signal
          elements[2]
        end
      end

      module ClockMuxSelection1
        def val
          elements[0]
        end

        def s1
          elements[1]
        end

        def s2
          elements[3]
        end
      end

      module ClockMuxSelection2
        def to_ast
          n :clockMux_selection, val.text_value, input: input, interval: interval, file: file
        end
      end

      def _nt_clockMux_selection
        start_index = index
        if node_cache[:clockMux_selection].has_key?(index)
          cached = node_cache[:clockMux_selection][index]
          if cached
            node_cache[:clockMux_selection][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1, s1 = index, []
        r2 = _nt_concat_number_list
        s1 << r2
        if r2
          if (match_len = has_terminal?(':', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('\':\'')
            r3 = nil
          end
          s1 << r3
          if r3
            r4 = _nt_concat_clock_signal
            s1 << r4
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(ClockMuxSelection0)
        else
          @index = i1
          r1 = nil
        end
        s0 << r1
        if r1
          r5 = _nt_s
          s0 << r5
          if r5
            if (match_len = has_terminal?(';', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('\';\'')
              r6 = nil
            end
            s0 << r6
            if r6
              r7 = _nt_s
              s0 << r7
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ClockMuxSelection1)
          r0.extend(ClockMuxSelection2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:clockMux_selection][start_index] = r0

        r0
      end

      module OneHotScanGroupDef0
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end

        def items
          elements[6]
        end

        def s3
          elements[7]
        end

        def s4
          elements[9]
        end
      end

      module OneHotScanGroupDef1
        def to_ast
          n :oneHotScanGroup_def, name.to_ast, *items.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
        end
      end

      def _nt_oneHotScanGroup_def
        start_index = index
        if node_cache[:oneHotScanGroup_def].has_key?(index)
          cached = node_cache[:oneHotScanGroup_def][index]
          if cached
            node_cache[:oneHotScanGroup_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('OneHotScanGroup', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'OneHotScanGroup\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_oneHotScanGroup_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?('{', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\'{\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                  if r6
                    s7, i7 = [], index
                    loop do
                      r8 = _nt_oneHotScanGroup_item
                      if r8
                        s7 << r8
                      else
                        break
                      end
                    end
                    if s7.empty?
                      @index = i7
                      r7 = nil
                    else
                      r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    end
                    s0 << r7
                    if r7
                      r9 = _nt_s
                      s0 << r9
                      if r9
                        if (match_len = has_terminal?('}', false, index))
                          r10 = true
                          @index += match_len
                        else
                          terminal_parse_failure('\'}\'')
                          r10 = nil
                        end
                        s0 << r10
                        if r10
                          r11 = _nt_s
                          s0 << r11
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(OneHotScanGroupDef0)
          r0.extend(OneHotScanGroupDef1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:oneHotScanGroup_def][start_index] = r0

        r0
      end

      module OneHotScanGroupItem0
        def S
          elements[1]
        end

        def signal
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module OneHotScanGroupItem1
        def to_ast
          n :oneHotScanGroup_item, signal.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_oneHotScanGroup_item
        start_index = index
        if node_cache[:oneHotScanGroup_item].has_key?(index)
          cached = node_cache[:oneHotScanGroup_item][index]
          if cached
            node_cache[:oneHotScanGroup_item][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('Port', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'Port\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_concat_scan_signal
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(OneHotScanGroupItem0)
          r0.extend(OneHotScanGroupItem1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:oneHotScanGroup_item][start_index] = r0

        r0
      end

      module OneHotDataGroupDef0
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end

        def items
          elements[6]
        end

        def s3
          elements[7]
        end

        def s4
          elements[9]
        end
      end

      module OneHotDataGroupDef1
        def to_ast
          n :oneHotDataGroup_def, name.to_ast, *items.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
        end
      end

      def _nt_oneHotDataGroup_def
        start_index = index
        if node_cache[:oneHotDataGroup_def].has_key?(index)
          cached = node_cache[:oneHotDataGroup_def][index]
          if cached
            node_cache[:oneHotDataGroup_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('OneHotDataGroup', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'OneHotDataGroup\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_oneHotDataGroup_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?('{', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\'{\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                  if r6
                    s7, i7 = [], index
                    loop do
                      r8 = _nt_oneHotDataGroup_item
                      if r8
                        s7 << r8
                      else
                        break
                      end
                    end
                    if s7.empty?
                      @index = i7
                      r7 = nil
                    else
                      r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    end
                    s0 << r7
                    if r7
                      r9 = _nt_s
                      s0 << r9
                      if r9
                        if (match_len = has_terminal?('}', false, index))
                          r10 = true
                          @index += match_len
                        else
                          terminal_parse_failure('\'}\'')
                          r10 = nil
                        end
                        s0 << r10
                        if r10
                          r11 = _nt_s
                          s0 << r11
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(OneHotDataGroupDef0)
          r0.extend(OneHotDataGroupDef1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:oneHotDataGroup_def][start_index] = r0

        r0
      end

      def _nt_oneHotDataGroup_item
        start_index = index
        if node_cache[:oneHotDataGroup_item].has_key?(index)
          cached = node_cache[:oneHotDataGroup_item][index]
          if cached
            node_cache[:oneHotDataGroup_item][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_instance_def
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_dataRegister_def
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_oneHotDataGroup_portSource
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:oneHotDataGroup_item][start_index] = r0

        r0
      end

      module OneHotDataGroupPortSource0
        def S
          elements[1]
        end

        def signal
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module OneHotDataGroupPortSource1
        def to_ast
          n :oneHotDataGroup_portSource, signal.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_oneHotDataGroup_portSource
        start_index = index
        if node_cache[:oneHotDataGroup_portSource].has_key?(index)
          cached = node_cache[:oneHotDataGroup_portSource][index]
          if cached
            node_cache[:oneHotDataGroup_portSource][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('Port', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'Port\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_concat_data_signal
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(OneHotDataGroupPortSource0)
          r0.extend(OneHotDataGroupPortSource1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:oneHotDataGroup_portSource][start_index] = r0

        r0
      end

      module ScanInterfaceDef0
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end

        def items
          elements[6]
        end

        def s3
          elements[7]
        end

        def s4
          elements[9]
        end
      end

      module ScanInterfaceDef1
        def to_ast
          n :scanInterface_def, name.to_ast, *items.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
        end
      end

      def _nt_scanInterface_def
        start_index = index
        if node_cache[:scanInterface_def].has_key?(index)
          cached = node_cache[:scanInterface_def][index]
          if cached
            node_cache[:scanInterface_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ScanInterface', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ScanInterface\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_scanInterface_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?('{', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\'{\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                  if r6
                    s7, i7 = [], index
                    loop do
                      r8 = _nt_scanInterface_item
                      if r8
                        s7 << r8
                      else
                        break
                      end
                    end
                    if s7.empty?
                      @index = i7
                      r7 = nil
                    else
                      r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    end
                    s0 << r7
                    if r7
                      r9 = _nt_s
                      s0 << r9
                      if r9
                        if (match_len = has_terminal?('}', false, index))
                          r10 = true
                          @index += match_len
                        else
                          terminal_parse_failure('\'}\'')
                          r10 = nil
                        end
                        s0 << r10
                        if r10
                          r11 = _nt_s
                          s0 << r11
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ScanInterfaceDef0)
          r0.extend(ScanInterfaceDef1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:scanInterface_def][start_index] = r0

        r0
      end

      def _nt_scanInterface_item
        start_index = index
        if node_cache[:scanInterface_item].has_key?(index)
          cached = node_cache[:scanInterface_item][index]
          if cached
            node_cache[:scanInterface_item][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_attribute_def
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_scanInterfacePort_def
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_defaultLoad_def
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              r4 = _nt_scanInterfaceChain_def
              if r4
                r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
                r0 = r4
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end

        node_cache[:scanInterface_item][start_index] = r0

        r0
      end

      module ScanInterfacePortDef0
        def S
          elements[1]
        end

        def signal
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module ScanInterfacePortDef1
        def to_ast
          n :scanInterfacePort_def, signal.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_scanInterfacePort_def
        start_index = index
        if node_cache[:scanInterfacePort_def].has_key?(index)
          cached = node_cache[:scanInterfacePort_def][index]
          if cached
            node_cache[:scanInterfacePort_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('Port', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'Port\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_reg_port_signal_id
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ScanInterfacePortDef0)
          r0.extend(ScanInterfacePortDef1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:scanInterfacePort_def][start_index] = r0

        r0
      end

      module ScanInterfaceChainDef0
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end

        def items
          elements[6]
        end

        def s3
          elements[7]
        end

        def s4
          elements[9]
        end
      end

      module ScanInterfaceChainDef1
        def to_ast
          n :scanInterfaceChain_def, name.to_ast, *items.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
        end
      end

      def _nt_scanInterfaceChain_def
        start_index = index
        if node_cache[:scanInterfaceChain_def].has_key?(index)
          cached = node_cache[:scanInterfaceChain_def][index]
          if cached
            node_cache[:scanInterfaceChain_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('Chain', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'Chain\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_scanInterfaceChain_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?('{', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\'{\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                  if r6
                    s7, i7 = [], index
                    loop do
                      r8 = _nt_scanInterfaceChain_item
                      if r8
                        s7 << r8
                      else
                        break
                      end
                    end
                    if s7.empty?
                      @index = i7
                      r7 = nil
                    else
                      r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    end
                    s0 << r7
                    if r7
                      r9 = _nt_s
                      s0 << r9
                      if r9
                        if (match_len = has_terminal?('}', false, index))
                          r10 = true
                          @index += match_len
                        else
                          terminal_parse_failure('\'}\'')
                          r10 = nil
                        end
                        s0 << r10
                        if r10
                          r11 = _nt_s
                          s0 << r11
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ScanInterfaceChainDef0)
          r0.extend(ScanInterfaceChainDef1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:scanInterfaceChain_def][start_index] = r0

        r0
      end

      def _nt_scanInterfaceChain_item
        start_index = index
        if node_cache[:scanInterfaceChain_item].has_key?(index)
          cached = node_cache[:scanInterfaceChain_item][index]
          if cached
            node_cache[:scanInterfaceChain_item][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_attribute_def
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_scanInterfacePort_def
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_defaultLoad_def
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:scanInterfaceChain_item][start_index] = r0

        r0
      end

      module DefaultLoadDef0
        def S
          elements[1]
        end

        def val
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module DefaultLoadDef1
        def to_ast
          n :defaultLoad_def, val.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_defaultLoad_def
        start_index = index
        if node_cache[:defaultLoad_def].has_key?(index)
          cached = node_cache[:defaultLoad_def][index]
          if cached
            node_cache[:defaultLoad_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('DefaultLoadValue', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'DefaultLoadValue\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_concat_number
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DefaultLoadDef0)
          r0.extend(DefaultLoadDef1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:defaultLoad_def][start_index] = r0

        r0
      end

      def _nt_accessLink_def
        start_index = index
        if node_cache[:accessLink_def].has_key?(index)
          cached = node_cache[:accessLink_def][index]
          if cached
            node_cache[:accessLink_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_accessLink1149_def
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_AccessLinkGeneric_def
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:accessLink_def][start_index] = r0

        r0
      end

      module AccessLinkGenericDef0
        def S1
          elements[1]
        end

        def v1
          elements[2]
        end

        def S2
          elements[3]
        end

        def S3
          elements[5]
        end

        def v2
          elements[6]
        end

        def s
          elements[7]
        end
      end

      module AccessLinkGenericDef1
        def to_ast
          n :AccessLinkGeneric_def, v1.to_ast, v2.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_AccessLinkGeneric_def
        start_index = index
        if node_cache[:AccessLinkGeneric_def].has_key?(index)
          cached = node_cache[:AccessLinkGeneric_def][index]
          if cached
            node_cache[:AccessLinkGeneric_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('AccessLink', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'AccessLink\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_SCALAR_ID
            s0 << r3
            if r3
              r4 = _nt_S
              s0 << r4
              if r4
                if (match_len = has_terminal?('Of', false, index))
                  r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('\'Of\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_S
                  s0 << r6
                  if r6
                    r7 = _nt_SCALAR_ID
                    s0 << r7
                    if r7
                      r8 = _nt_s
                      s0 << r8
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AccessLinkGenericDef0)
          r0.extend(AccessLinkGenericDef1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:AccessLinkGeneric_def][start_index] = r0

        r0
      end

      module AccessLink1149Def0
        def S1
          elements[1]
        end

        def link
          elements[2]
        end

        def S2
          elements[3]
        end

        def S3
          elements[5]
        end

        def type
          elements[6]
        end

        def s1
          elements[7]
        end

        def s2
          elements[9]
        end

        def S4
          elements[11]
        end

        def bname
          elements[12]
        end

        def s3
          elements[13]
        end

        def s4
          elements[15]
        end

        def refs
          elements[16]
        end

        def s5
          elements[17]
        end

        def s6
          elements[19]
        end
      end

      module AccessLink1149Def1
        def to_ast
          n :accessLink1149_def, ling.to_ast, type.text_value, bname.to_ast, *refs.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
        end
      end

      def _nt_accessLink1149_def
        start_index = index
        if node_cache[:accessLink1149_def].has_key?(index)
          cached = node_cache[:accessLink1149_def][index]
          if cached
            node_cache[:accessLink1149_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('AccessLink', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'AccessLink\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_accessLink_name
            s0 << r3
            if r3
              r4 = _nt_S
              s0 << r4
              if r4
                if (match_len = has_terminal?('Of', false, index))
                  r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('\'Of\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_S
                  s0 << r6
                  if r6
                    i7 = index
                    if (match_len = has_terminal?('STD_1149_1_2001', false, index))
                      r8 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                      @index += match_len
                    else
                      terminal_parse_failure('\'STD_1149_1_2001\'')
                      r8 = nil
                    end
                    if r8
                      r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
                      r7 = r8
                    else
                      if (match_len = has_terminal?('STD_1149_1_2013', false, index))
                        r9 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                        @index += match_len
                      else
                        terminal_parse_failure('\'STD_1149_1_2013\'')
                        r9 = nil
                      end
                      if r9
                        r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
                        r7 = r9
                      else
                        @index = i7
                        r7 = nil
                      end
                    end
                    s0 << r7
                    if r7
                      r10 = _nt_s
                      s0 << r10
                      if r10
                        if (match_len = has_terminal?('{', false, index))
                          r11 = true
                          @index += match_len
                        else
                          terminal_parse_failure('\'{\'')
                          r11 = nil
                        end
                        s0 << r11
                        if r11
                          r12 = _nt_s
                          s0 << r12
                          if r12
                            if (match_len = has_terminal?('BSDLEntity', false, index))
                              r13 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                              @index += match_len
                            else
                              terminal_parse_failure('\'BSDLEntity\'')
                              r13 = nil
                            end
                            s0 << r13
                            if r13
                              r14 = _nt_S
                              s0 << r14
                              if r14
                                r15 = _nt_bsdlEntity_name
                                s0 << r15
                                if r15
                                  r16 = _nt_s
                                  s0 << r16
                                  if r16
                                    if (match_len = has_terminal?(';', false, index))
                                      r17 = true
                                      @index += match_len
                                    else
                                      terminal_parse_failure('\';\'')
                                      r17 = nil
                                    end
                                    s0 << r17
                                    if r17
                                      r18 = _nt_s
                                      s0 << r18
                                      if r18
                                        s19, i19 = [], index
                                        loop do
                                          r20 = _nt_bsdl_instr_ref
                                          if r20
                                            s19 << r20
                                          else
                                            break
                                          end
                                        end
                                        if s19.empty?
                                          @index = i19
                                          r19 = nil
                                        else
                                          r19 = instantiate_node(SyntaxNode,input, i19...index, s19)
                                        end
                                        s0 << r19
                                        if r19
                                          r21 = _nt_s
                                          s0 << r21
                                          if r21
                                            if (match_len = has_terminal?('}', false, index))
                                              r22 = true
                                              @index += match_len
                                            else
                                              terminal_parse_failure('\'}\'')
                                              r22 = nil
                                            end
                                            s0 << r22
                                            if r22
                                              r23 = _nt_s
                                              s0 << r23
                                            end
                                          end
                                        end
                                      end
                                    end
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AccessLink1149Def0)
          r0.extend(AccessLink1149Def1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:accessLink1149_def][start_index] = r0

        r0
      end

      module BsdlInstrRef0
        def name
          elements[0]
        end

        def s1
          elements[1]
        end

        def s2
          elements[3]
        end

        def items
          elements[4]
        end

        def s3
          elements[5]
        end

        def s4
          elements[7]
        end
      end

      module BsdlInstrRef1
        def to_ast
          n :bsdl_instr_ref, name.to_ast, *items.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
        end
      end

      def _nt_bsdl_instr_ref
        start_index = index
        if node_cache[:bsdl_instr_ref].has_key?(index)
          cached = node_cache[:bsdl_instr_ref][index]
          if cached
            node_cache[:bsdl_instr_ref][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_bsdl_instr_name
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            if (match_len = has_terminal?('{', false, index))
              r3 = true
              @index += match_len
            else
              terminal_parse_failure('\'{\'')
              r3 = nil
            end
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                s5, i5 = [], index
                loop do
                  r6 = _nt_bsdl_instr_selected_item
                  if r6
                    s5 << r6
                  else
                    break
                  end
                end
                if s5.empty?
                  @index = i5
                  r5 = nil
                else
                  r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
                end
                s0 << r5
                if r5
                  r7 = _nt_s
                  s0 << r7
                  if r7
                    if (match_len = has_terminal?('}', false, index))
                      r8 = true
                      @index += match_len
                    else
                      terminal_parse_failure('\'}\'')
                      r8 = nil
                    end
                    s0 << r8
                    if r8
                      r9 = _nt_s
                      s0 << r9
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(BsdlInstrRef0)
          r0.extend(BsdlInstrRef1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:bsdl_instr_ref][start_index] = r0

        r0
      end

      module BsdlInstrSelectedItem0
        def accessLink1149_ScanInterface_name
          elements[0]
        end

      end

      module BsdlInstrSelectedItem1
        def s1
          elements[1]
        end

        def s2
          elements[3]
        end

        def names
          elements[4]
        end

        def s3
          elements[5]
        end

      end

      module BsdlInstrSelectedItem2
        def accessLink1149_ActiveSignal_name
          elements[0]
        end

      end

      module BsdlInstrSelectedItem3
        def s1
          elements[1]
        end

        def s2
          elements[3]
        end

        def names
          elements[4]
        end

        def s3
          elements[5]
        end

      end

      module BsdlInstrSelectedItem4
        def d
          elements[0]
        end

        def s
          elements[1]
        end
      end

      module BsdlInstrSelectedItem5
        def to_ast
          n :bsdl_instr_selected_item, *d.names.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
        end
      end

      def _nt_bsdl_instr_selected_item
        start_index = index
        if node_cache[:bsdl_instr_selected_item].has_key?(index)
          cached = node_cache[:bsdl_instr_selected_item][index]
          if cached
            node_cache[:bsdl_instr_selected_item][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        i2, s2 = index, []
        if (match_len = has_terminal?('ScanInterface', false, index))
          r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ScanInterface\'')
          r3 = nil
        end
        s2 << r3
        if r3
          r4 = _nt_s
          s2 << r4
          if r4
            if (match_len = has_terminal?('{', false, index))
              r5 = true
              @index += match_len
            else
              terminal_parse_failure('\'{\'')
              r5 = nil
            end
            s2 << r5
            if r5
              r6 = _nt_s
              s2 << r6
              if r6
                s7, i7 = [], index
                loop do
                  i8, s8 = index, []
                  r9 = _nt_accessLink1149_ScanInterface_name
                  s8 << r9
                  if r9
                    if (match_len = has_terminal?(';', false, index))
                      r10 = true
                      @index += match_len
                    else
                      terminal_parse_failure('\';\'')
                      r10 = nil
                    end
                    s8 << r10
                  end
                  if s8.last
                    r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
                    r8.extend(BsdlInstrSelectedItem0)
                  else
                    @index = i8
                    r8 = nil
                  end
                  if r8
                    s7 << r8
                  else
                    break
                  end
                end
                if s7.empty?
                  @index = i7
                  r7 = nil
                else
                  r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                end
                s2 << r7
                if r7
                  r11 = _nt_s
                  s2 << r11
                  if r11
                    if (match_len = has_terminal?('}', false, index))
                      r12 = true
                      @index += match_len
                    else
                      terminal_parse_failure('\'}\'')
                      r12 = nil
                    end
                    s2 << r12
                  end
                end
              end
            end
          end
        end
        if s2.last
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          r2.extend(BsdlInstrSelectedItem1)
        else
          @index = i2
          r2 = nil
        end
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          i13, s13 = index, []
          if (match_len = has_terminal?('ActiveSignals', false, index))
            r14 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'ActiveSignals\'')
            r14 = nil
          end
          s13 << r14
          if r14
            r15 = _nt_s
            s13 << r15
            if r15
              if (match_len = has_terminal?('{', false, index))
                r16 = true
                @index += match_len
              else
                terminal_parse_failure('\'{\'')
                r16 = nil
              end
              s13 << r16
              if r16
                r17 = _nt_s
                s13 << r17
                if r17
                  s18, i18 = [], index
                  loop do
                    i19, s19 = index, []
                    r20 = _nt_accessLink1149_ActiveSignal_name
                    s19 << r20
                    if r20
                      if (match_len = has_terminal?(';', false, index))
                        r21 = true
                        @index += match_len
                      else
                        terminal_parse_failure('\';\'')
                        r21 = nil
                      end
                      s19 << r21
                    end
                    if s19.last
                      r19 = instantiate_node(SyntaxNode,input, i19...index, s19)
                      r19.extend(BsdlInstrSelectedItem2)
                    else
                      @index = i19
                      r19 = nil
                    end
                    if r19
                      s18 << r19
                    else
                      break
                    end
                  end
                  if s18.empty?
                    @index = i18
                    r18 = nil
                  else
                    r18 = instantiate_node(SyntaxNode,input, i18...index, s18)
                  end
                  s13 << r18
                  if r18
                    r22 = _nt_s
                    s13 << r22
                    if r22
                      if (match_len = has_terminal?('}', false, index))
                        r23 = true
                        @index += match_len
                      else
                        terminal_parse_failure('\'}\'')
                        r23 = nil
                      end
                      s13 << r23
                    end
                  end
                end
              end
            end
          end
          if s13.last
            r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
            r13.extend(BsdlInstrSelectedItem3)
          else
            @index = i13
            r13 = nil
          end
          if r13
            r13 = SyntaxNode.new(input, (index-1)...index) if r13 == true
            r1 = r13
          else
            @index = i1
            r1 = nil
          end
        end
        s0 << r1
        if r1
          r24 = _nt_s
          s0 << r24
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(BsdlInstrSelectedItem4)
          r0.extend(BsdlInstrSelectedItem5)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:bsdl_instr_selected_item][start_index] = r0

        r0
      end

      module AccessLink1149ScanInterfaceName0
        def scanInterface_name
          elements[1]
        end
      end

      module AccessLink1149ScanInterfaceName1
        def instance_name
          elements[0]
        end

      end

      module AccessLink1149ScanInterfaceName2
        def val
          elements[0]
        end

        def s
          elements[1]
        end
      end

      module AccessLink1149ScanInterfaceName3
        def to_ast
          n :accessLink1149_ScanInterface_name, val.text_value, input: input, interval: interval, file: file
        end
      end

      def _nt_accessLink1149_ScanInterface_name
        start_index = index
        if node_cache[:accessLink1149_ScanInterface_name].has_key?(index)
          cached = node_cache[:accessLink1149_ScanInterface_name][index]
          if cached
            node_cache[:accessLink1149_ScanInterface_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1, s1 = index, []
        r2 = _nt_instance_name
        s1 << r2
        if r2
          i4, s4 = index, []
          if (match_len = has_terminal?('.', false, index))
            r5 = true
            @index += match_len
          else
            terminal_parse_failure('\'.\'')
            r5 = nil
          end
          s4 << r5
          if r5
            r6 = _nt_scanInterface_name
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(AccessLink1149ScanInterfaceName0)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r3 = r4
          else
            r3 = instantiate_node(SyntaxNode,input, index...index)
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(AccessLink1149ScanInterfaceName1)
        else
          @index = i1
          r1 = nil
        end
        s0 << r1
        if r1
          r7 = _nt_s
          s0 << r7
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AccessLink1149ScanInterfaceName2)
          r0.extend(AccessLink1149ScanInterfaceName3)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:accessLink1149_ScanInterface_name][start_index] = r0

        r0
      end

      module AliasDef0
        def s1
          elements[1]
        end

        def items
          elements[2]
        end

        def s2
          elements[3]
        end

        def s3
          elements[5]
        end
      end

      module AliasDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end

        def signal
          elements[6]
        end

        def s3
          elements[7]
        end

        def d
          elements[8]
        end

        def s4
          elements[9]
        end
      end

      module AliasDef2
        def to_ast
          if d.respond_to?(:items)
            n :alias_def, name.to_ast, signal.to_ast, *d.items.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
          else
            n :alias_def, name.to_ast, signal.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_alias_def
        start_index = index
        if node_cache[:alias_def].has_key?(index)
          cached = node_cache[:alias_def][index]
          if cached
            node_cache[:alias_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('Alias', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'Alias\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_alias_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?('=', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\'=\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                  if r6
                    r7 = _nt_concat_hier_data_signal
                    s0 << r7
                    if r7
                      r8 = _nt_s
                      s0 << r8
                      if r8
                        i9 = index
                        if (match_len = has_terminal?(';', false, index))
                          r10 = true
                          @index += match_len
                        else
                          terminal_parse_failure('\';\'')
                          r10 = nil
                        end
                        if r10
                          r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                          r9 = r10
                        else
                          i11, s11 = index, []
                          if (match_len = has_terminal?('{', false, index))
                            r12 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'{\'')
                            r12 = nil
                          end
                          s11 << r12
                          if r12
                            r13 = _nt_s
                            s11 << r13
                            if r13
                              s14, i14 = [], index
                              loop do
                                r15 = _nt_alias_item
                                if r15
                                  s14 << r15
                                else
                                  break
                                end
                              end
                              if s14.empty?
                                @index = i14
                                r14 = nil
                              else
                                r14 = instantiate_node(SyntaxNode,input, i14...index, s14)
                              end
                              s11 << r14
                              if r14
                                r16 = _nt_s
                                s11 << r16
                                if r16
                                  if (match_len = has_terminal?('}', false, index))
                                    r17 = true
                                    @index += match_len
                                  else
                                    terminal_parse_failure('\'}\'')
                                    r17 = nil
                                  end
                                  s11 << r17
                                  if r17
                                    r18 = _nt_s
                                    s11 << r18
                                  end
                                end
                              end
                            end
                          end
                          if s11.last
                            r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
                            r11.extend(AliasDef0)
                          else
                            @index = i11
                            r11 = nil
                          end
                          if r11
                            r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
                            r9 = r11
                          else
                            @index = i9
                            r9 = nil
                          end
                        end
                        s0 << r9
                        if r9
                          r19 = _nt_s
                          s0 << r19
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AliasDef1)
          r0.extend(AliasDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:alias_def][start_index] = r0

        r0
      end

      def _nt_alias_item
        start_index = index
        if node_cache[:alias_item].has_key?(index)
          cached = node_cache[:alias_item][index]
          if cached
            node_cache[:alias_item][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_attribute_def
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_access_together
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_alias_iApplyEndState
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              r4 = _nt_alias_refEnum
              if r4
                r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
                r0 = r4
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end

        node_cache[:alias_item][start_index] = r0

        r0
      end

      module AliasIApplyEndState0
        def S
          elements[1]
        end

        def num
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module AliasIApplyEndState1
        def to_ast
          n :alias_iApplyEndState, num.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_alias_iApplyEndState
        start_index = index
        if node_cache[:alias_iApplyEndState].has_key?(index)
          cached = node_cache[:alias_iApplyEndState][index]
          if cached
            node_cache[:alias_iApplyEndState][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('iApplyEndState', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'iApplyEndState\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_concat_number
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AliasIApplyEndState0)
          r0.extend(AliasIApplyEndState1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:alias_iApplyEndState][start_index] = r0

        r0
      end

      module AliasRefEnum0
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end
      end

      module AliasRefEnum1
        def to_ast
          n :refEnum, name.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_alias_refEnum
        start_index = index
        if node_cache[:alias_refEnum].has_key?(index)
          cached = node_cache[:alias_refEnum][index]
          if cached
            node_cache[:alias_refEnum][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('RefEnum', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'RefEnum\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_enum_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(';', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AliasRefEnum0)
          r0.extend(AliasRefEnum1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:alias_refEnum][start_index] = r0

        r0
      end

      module AccessTogether0
        def s1
          elements[1]
        end

        def s2
          elements[3]
        end
      end

      module AccessTogether1
        def to_ast
          n :access_together, input: input, interval: interval, file: file
        end
      end

      def _nt_access_together
        start_index = index
        if node_cache[:access_together].has_key?(index)
          cached = node_cache[:access_together][index]
          if cached
            node_cache[:access_together][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('AccessTogether', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'AccessTogether\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            if (match_len = has_terminal?(';', false, index))
              r3 = true
              @index += match_len
            else
              terminal_parse_failure('\';\'')
              r3 = nil
            end
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AccessTogether0)
          r0.extend(AccessTogether1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:access_together][start_index] = r0

        r0
      end

      module ConcatHierDataSignal0
        def s1
          elements[0]
        end

        def s2
          elements[2]
        end

        def signal
          elements[3]
        end
      end

      module ConcatHierDataSignal1
        def s1
          elements[0]
        end

        def s2
          elements[1]
        end
      end

      module ConcatHierDataSignal2
        def to_ast
          if s2.empty?
            s1.to_ast
          else
            n :concat, s1.to_ast, *s2.elements.map{ |e| e.signal.to_ast }, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_concat_hier_data_signal
        start_index = index
        if node_cache[:concat_hier_data_signal].has_key?(index)
          cached = node_cache[:concat_hier_data_signal][index]
          if cached
            node_cache[:concat_hier_data_signal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        r2 = _nt_inverted_hier_data_signal
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          r3 = _nt_hier_data_signal
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r1 = r3
          else
            @index = i1
            r1 = nil
          end
        end
        s0 << r1
        if r1
          s4, i4 = [], index
          loop do
            i5, s5 = index, []
            r6 = _nt_s
            s5 << r6
            if r6
              if (match_len = has_terminal?(',', false, index))
                r7 = true
                @index += match_len
              else
                terminal_parse_failure('\',\'')
                r7 = nil
              end
              s5 << r7
              if r7
                r8 = _nt_s
                s5 << r8
                if r8
                  i9 = index
                  r10 = _nt_inverted_hier_data_signal
                  if r10
                    r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                    r9 = r10
                  else
                    r11 = _nt_hier_data_signal
                    if r11
                      r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
                      r9 = r11
                    else
                      @index = i9
                      r9 = nil
                    end
                  end
                  s5 << r9
                end
              end
            end
            if s5.last
              r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
              r5.extend(ConcatHierDataSignal0)
            else
              @index = i5
              r5 = nil
            end
            if r5
              s4 << r5
            else
              break
            end
          end
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
          s0 << r4
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ConcatHierDataSignal1)
          r0.extend(ConcatHierDataSignal2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:concat_hier_data_signal][start_index] = r0

        r0
      end

      module HierDataSignal0
        def name
          elements[0]
        end

      end

      module HierDataSignal1
        def instances
          elements[0]
        end

        def signal
          elements[1]
        end
      end

      module HierDataSignal2
        def to_ast
          if !instances.empty?
            n :hier_data_signal, *instances.elements.map{ |e| e.name.to_ast }, signal.to_ast, input: input, interval: interval, file: file
          else
            signal.to_ast
          end
        end
      end

      def _nt_hier_data_signal
        start_index = index
        if node_cache[:hier_data_signal].has_key?(index)
          cached = node_cache[:hier_data_signal][index]
          if cached
            node_cache[:hier_data_signal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        s1, i1 = [], index
        loop do
          i2, s2 = index, []
          r3 = _nt_instance_name
          s2 << r3
          if r3
            if (match_len = has_terminal?('.', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure('\'.\'')
              r4 = nil
            end
            s2 << r4
          end
          if s2.last
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
            r2.extend(HierDataSignal0)
          else
            @index = i2
            r2 = nil
          end
          if r2
            s1 << r2
          else
            break
          end
        end
        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        s0 << r1
        if r1
          r5 = _nt_reg_port_signal_id
          s0 << r5
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(HierDataSignal1)
          r0.extend(HierDataSignal2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:hier_data_signal][start_index] = r0

        r0
      end

      module InvertedHierDataSignal0
        def name
          elements[0]
        end

      end

      module InvertedHierDataSignal1
        def instances
          elements[1]
        end

        def signal
          elements[2]
        end
      end

      module InvertedHierDataSignal2
        def to_ast
          if !instances.empty?
            n :inverted_hier_data_signal, *instances.elements.map{ |e| e.name.to_ast }, signal.to_ast, input: input, interval: interval, file: file
          else
            n :inverted_signal, signal.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_inverted_hier_data_signal
        start_index = index
        if node_cache[:inverted_hier_data_signal].has_key?(index)
          cached = node_cache[:inverted_hier_data_signal][index]
          if cached
            node_cache[:inverted_hier_data_signal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('~', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('\'~\'')
          r1 = nil
        end
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            r4 = _nt_instance_name
            s3 << r4
            if r4
              if (match_len = has_terminal?('.', false, index))
                r5 = true
                @index += match_len
              else
                terminal_parse_failure('\'.\'')
                r5 = nil
              end
              s3 << r5
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(InvertedHierDataSignal0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
          if r2
            r6 = _nt_reg_port_signal_id
            s0 << r6
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(InvertedHierDataSignal1)
          r0.extend(InvertedHierDataSignal2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:inverted_hier_data_signal][start_index] = r0

        r0
      end

      module EnumDef0
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end

        def items
          elements[6]
        end

        def s3
          elements[7]
        end

        def s4
          elements[9]
        end
      end

      module EnumDef1
        def to_ast
          n :enum_def, name.to_ast, *items.elements.map{ |e| e.to_ast }, input: input, interval: interval, file: file
        end
      end

      def _nt_enum_def
        start_index = index
        if node_cache[:enum_def].has_key?(index)
          cached = node_cache[:enum_def][index]
          if cached
            node_cache[:enum_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('Enum', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'Enum\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_enum_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?('{', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\'{\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                  if r6
                    s7, i7 = [], index
                    loop do
                      r8 = _nt_enum_item
                      if r8
                        s7 << r8
                      else
                        break
                      end
                    end
                    if s7.empty?
                      @index = i7
                      r7 = nil
                    else
                      r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    end
                    s0 << r7
                    if r7
                      r9 = _nt_s
                      s0 << r9
                      if r9
                        if (match_len = has_terminal?('}', false, index))
                          r10 = true
                          @index += match_len
                        else
                          terminal_parse_failure('\'}\'')
                          r10 = nil
                        end
                        s0 << r10
                        if r10
                          r11 = _nt_s
                          s0 << r11
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(EnumDef0)
          r0.extend(EnumDef1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:enum_def][start_index] = r0

        r0
      end

      module EnumItem0
        def sym
          elements[0]
        end

        def s1
          elements[1]
        end

        def s2
          elements[3]
        end

        def val
          elements[4]
        end

        def s3
          elements[5]
        end

        def s4
          elements[7]
        end
      end

      module EnumItem1
        def to_ast
          n :enum_item, sym.to_ast, val.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_enum_item
        start_index = index
        if node_cache[:enum_item].has_key?(index)
          cached = node_cache[:enum_item][index]
          if cached
            node_cache[:enum_item][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_enum_symbol
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            if (match_len = has_terminal?('=', false, index))
              r3 = true
              @index += match_len
            else
              terminal_parse_failure('\'=\'')
              r3 = nil
            end
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                r5 = _nt_enum_value
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                  if r6
                    if (match_len = has_terminal?(';', false, index))
                      r7 = true
                      @index += match_len
                    else
                      terminal_parse_failure('\';\'')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      r8 = _nt_s
                      s0 << r8
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(EnumItem0)
          r0.extend(EnumItem1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:enum_item][start_index] = r0

        r0
      end

      module ParameterDef0
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end

        def val
          elements[6]
        end

        def s3
          elements[7]
        end

        def s4
          elements[9]
        end
      end

      module ParameterDef1
        def to_ast
          n :parameter_def, name.to_ast, val.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_parameter_def
        start_index = index
        if node_cache[:parameter_def].has_key?(index)
          cached = node_cache[:parameter_def][index]
          if cached
            node_cache[:parameter_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('Parameter', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'Parameter\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_parameter_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?('=', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\'=\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                  if r6
                    r7 = _nt_parameter_value
                    s0 << r7
                    if r7
                      r8 = _nt_s
                      s0 << r8
                      if r8
                        if (match_len = has_terminal?(';', false, index))
                          r9 = true
                          @index += match_len
                        else
                          terminal_parse_failure('\';\'')
                          r9 = nil
                        end
                        s0 << r9
                        if r9
                          r10 = _nt_s
                          s0 << r10
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ParameterDef0)
          r0.extend(ParameterDef1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:parameter_def][start_index] = r0

        r0
      end

      module LocalParameterDef0
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[5]
        end

        def val
          elements[6]
        end

        def s3
          elements[7]
        end

        def s4
          elements[9]
        end
      end

      module LocalParameterDef1
        def to_ast
          n :localParameter_def, name.to_ast, val.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_localParameter_def
        start_index = index
        if node_cache[:localParameter_def].has_key?(index)
          cached = node_cache[:localParameter_def][index]
          if cached
            node_cache[:localParameter_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('LocalParameter', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'LocalParameter\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_parameter_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?('=', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\'=\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                  if r6
                    r7 = _nt_parameter_value
                    s0 << r7
                    if r7
                      r8 = _nt_s
                      s0 << r8
                      if r8
                        if (match_len = has_terminal?(';', false, index))
                          r9 = true
                          @index += match_len
                        else
                          terminal_parse_failure('\';\'')
                          r9 = nil
                        end
                        s0 << r9
                        if r9
                          r10 = _nt_s
                          s0 << r10
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(LocalParameterDef0)
          r0.extend(LocalParameterDef1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:localParameter_def][start_index] = r0

        r0
      end

      def _nt_parameter_value
        start_index = index
        if node_cache[:parameter_value].has_key?(index)
          cached = node_cache[:parameter_value][index]
          if cached
            node_cache[:parameter_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_concat_string
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_concat_number
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:parameter_value][start_index] = r0

        r0
      end

      module ConcatString0
        def s
          elements[1]
        end

        def val
          elements[2]
        end
      end

      module ConcatString1
        def s1
          elements[0]
        end

        def s2
          elements[1]
        end

        def s
          elements[2]
        end
      end

      module ConcatString2
        def to_ast
          if s2.empty?
            s1.to_ast
          else
            n :concat, s1.to_ast, *s2.elements.map{ |e| e.val.to_ast }, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_concat_string
        start_index = index
        if node_cache[:concat_string].has_key?(index)
          cached = node_cache[:concat_string][index]
          if cached
            node_cache[:concat_string][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        r2 = _nt_parameter_ref
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          r3 = _nt_STRING
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r1 = r3
          else
            @index = i1
            r1 = nil
          end
        end
        s0 << r1
        if r1
          s4, i4 = [], index
          loop do
            i5, s5 = index, []
            if (match_len = has_terminal?(',', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('\',\'')
              r6 = nil
            end
            s5 << r6
            if r6
              r7 = _nt_s
              s5 << r7
              if r7
                i8 = index
                r9 = _nt_parameter_ref
                if r9
                  r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
                  r8 = r9
                else
                  r10 = _nt_STRING
                  if r10
                    r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                    r8 = r10
                  else
                    @index = i8
                    r8 = nil
                  end
                end
                s5 << r8
              end
            end
            if s5.last
              r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
              r5.extend(ConcatString0)
            else
              @index = i5
              r5 = nil
            end
            if r5
              s4 << r5
            else
              break
            end
          end
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
          s0 << r4
          if r4
            r11 = _nt_s
            s0 << r11
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ConcatString1)
          r0.extend(ConcatString2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:concat_string][start_index] = r0

        r0
      end

      module AttributeDef0
        def s1
          elements[1]
        end

        def val
          elements[2]
        end

        def s2
          elements[3]
        end
      end

      module AttributeDef1
        def S
          elements[1]
        end

        def name
          elements[2]
        end

        def s1
          elements[3]
        end

        def s2
          elements[6]
        end
      end

      module AttributeDef2
        def to_ast
          n :attribute_def, name.to_ast, val.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_attribute_def
        start_index = index
        if node_cache[:attribute_def].has_key?(index)
          cached = node_cache[:attribute_def][index]
          if cached
            node_cache[:attribute_def][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('Attribute', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'Attribute\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_attribute_name
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i6, s6 = index, []
                if (match_len = has_terminal?('=', false, index))
                  r7 = true
                  @index += match_len
                else
                  terminal_parse_failure('\'=\'')
                  r7 = nil
                end
                s6 << r7
                if r7
                  r8 = _nt_s
                  s6 << r8
                  if r8
                    r9 = _nt_attribute_value
                    s6 << r9
                    if r9
                      r10 = _nt_s
                      s6 << r10
                    end
                  end
                end
                if s6.last
                  r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
                  r6.extend(AttributeDef0)
                else
                  @index = i6
                  r6 = nil
                end
                if r6
                  r5 = r6
                else
                  r5 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r5
                if r5
                  if (match_len = has_terminal?(';', false, index))
                    r11 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\';\'')
                    r11 = nil
                  end
                  s0 << r11
                  if r11
                    r12 = _nt_s
                    s0 << r12
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AttributeDef1)
          r0.extend(AttributeDef2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:attribute_def][start_index] = r0

        r0
      end

      def _nt_attribute_value
        start_index = index
        if node_cache[:attribute_value].has_key?(index)
          cached = node_cache[:attribute_value][index]
          if cached
            node_cache[:attribute_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_concat_string
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_concat_number
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:attribute_value][start_index] = r0

        r0
      end

      def _nt_STRING
        start_index = index
        if node_cache[:STRING].has_key?(index)
          cached = node_cache[:STRING][index]
          if cached
            node_cache[:STRING][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_double_quoted_string
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_single_quoted_string
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:STRING][start_index] = r0

        r0
      end

      module DoubleQuotedString0
      end

      module DoubleQuotedString1
        def val
          elements[1]
        end

      end

      module DoubleQuotedString2
        def to_ast
          n :STRING, val.text_value, input: input, interval: interval, file: file
        end
      end

      def _nt_double_quoted_string
        start_index = index
        if node_cache[:double_quoted_string].has_key?(index)
          cached = node_cache[:double_quoted_string][index]
          if cached
            node_cache[:double_quoted_string][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('"', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('\'"\'')
          r1 = nil
        end
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            i4 = index
            if (match_len = has_terminal?('"', false, index))
              r5 = true
              @index += match_len
            else
              terminal_parse_failure('\'"\'')
              r5 = nil
            end
            if r5
              @index = i4
              r4 = nil
              terminal_parse_failure('\'"\'', true)
            else
              terminal_failures.pop
              @index = i4
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s3 << r4
            if r4
              i6 = index
              if (match_len = has_terminal?('\"', false, index))
                r7 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                @index += match_len
              else
                terminal_parse_failure('\'\\"\'')
                r7 = nil
              end
              if r7
                r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                r6 = r7
              else
                if index < input_length
                  r8 = true
                  @index += 1
                else
                  terminal_parse_failure("any character")
                  r8 = nil
                end
                if r8
                  r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
                  r6 = r8
                else
                  @index = i6
                  r6 = nil
                end
              end
              s3 << r6
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(DoubleQuotedString0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
          if r2
            if (match_len = has_terminal?('"', false, index))
              r9 = true
              @index += match_len
            else
              terminal_parse_failure('\'"\'')
              r9 = nil
            end
            s0 << r9
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DoubleQuotedString1)
          r0.extend(DoubleQuotedString2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:double_quoted_string][start_index] = r0

        r0
      end

      module SingleQuotedString0
      end

      module SingleQuotedString1
        def val
          elements[1]
        end

      end

      module SingleQuotedString2
        def to_ast
          n :STRING, val.text_value, input: input, interval: interval, file: file
        end
      end

      def _nt_single_quoted_string
        start_index = index
        if node_cache[:single_quoted_string].has_key?(index)
          cached = node_cache[:single_quoted_string][index]
          if cached
            node_cache[:single_quoted_string][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?("'", false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('"\'"')
          r1 = nil
        end
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            i4 = index
            if (match_len = has_terminal?("'", false, index))
              r5 = true
              @index += match_len
            else
              terminal_parse_failure('"\'"')
              r5 = nil
            end
            if r5
              @index = i4
              r4 = nil
              terminal_parse_failure('"\'"', true)
            else
              terminal_failures.pop
              @index = i4
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s3 << r4
            if r4
              i6 = index
              if (match_len = has_terminal?("\\'", false, index))
                r7 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                @index += match_len
              else
                terminal_parse_failure('"\\\\\'"')
                r7 = nil
              end
              if r7
                r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                r6 = r7
              else
                if index < input_length
                  r8 = true
                  @index += 1
                else
                  terminal_parse_failure("any character")
                  r8 = nil
                end
                if r8
                  r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
                  r6 = r8
                else
                  @index = i6
                  r6 = nil
                end
              end
              s3 << r6
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(SingleQuotedString0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
          if r2
            if (match_len = has_terminal?("'", false, index))
              r9 = true
              @index += match_len
            else
              terminal_parse_failure('"\'"')
              r9 = nil
            end
            s0 << r9
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SingleQuotedString1)
          r0.extend(SingleQuotedString2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:single_quoted_string][start_index] = r0

        r0
      end

      def _nt_enum_name
        start_index = index
        if node_cache[:enum_name].has_key?(index)
          cached = node_cache[:enum_name][index]
          if cached
            node_cache[:enum_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_SCALAR_ID

        node_cache[:enum_name][start_index] = r0

        r0
      end

      def _nt_enum_symbol
        start_index = index
        if node_cache[:enum_symbol].has_key?(index)
          cached = node_cache[:enum_symbol][index]
          if cached
            node_cache[:enum_symbol][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_SCALAR_ID

        node_cache[:enum_symbol][start_index] = r0

        r0
      end

      def _nt_parameter_name
        start_index = index
        if node_cache[:parameter_name].has_key?(index)
          cached = node_cache[:parameter_name][index]
          if cached
            node_cache[:parameter_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_SCALAR_ID

        node_cache[:parameter_name][start_index] = r0

        r0
      end

      def _nt_attribute_name
        start_index = index
        if node_cache[:attribute_name].has_key?(index)
          cached = node_cache[:attribute_name][index]
          if cached
            node_cache[:attribute_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_SCALAR_ID

        node_cache[:attribute_name][start_index] = r0

        r0
      end

      def _nt_enum_value
        start_index = index
        if node_cache[:enum_value].has_key?(index)
          cached = node_cache[:enum_value][index]
          if cached
            node_cache[:enum_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_concat_number

        node_cache[:enum_value][start_index] = r0

        r0
      end

      def _nt_alias_name
        start_index = index
        if node_cache[:alias_name].has_key?(index)
          cached = node_cache[:alias_name][index]
          if cached
            node_cache[:alias_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_reg_port_signal_id

        node_cache[:alias_name][start_index] = r0

        r0
      end

      def _nt_accessLink1149_ActiveSignal_name
        start_index = index
        if node_cache[:accessLink1149_ActiveSignal_name].has_key?(index)
          cached = node_cache[:accessLink1149_ActiveSignal_name][index]
          if cached
            node_cache[:accessLink1149_ActiveSignal_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_reg_port_signal_id

        node_cache[:accessLink1149_ActiveSignal_name][start_index] = r0

        r0
      end

      def _nt_accessLink_name
        start_index = index
        if node_cache[:accessLink_name].has_key?(index)
          cached = node_cache[:accessLink_name][index]
          if cached
            node_cache[:accessLink_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_SCALAR_ID

        node_cache[:accessLink_name][start_index] = r0

        r0
      end

      def _nt_bsdlEntity_name
        start_index = index
        if node_cache[:bsdlEntity_name].has_key?(index)
          cached = node_cache[:bsdlEntity_name][index]
          if cached
            node_cache[:bsdlEntity_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_SCALAR_ID

        node_cache[:bsdlEntity_name][start_index] = r0

        r0
      end

      def _nt_bsdl_instr_name
        start_index = index
        if node_cache[:bsdl_instr_name].has_key?(index)
          cached = node_cache[:bsdl_instr_name][index]
          if cached
            node_cache[:bsdl_instr_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_SCALAR_ID

        node_cache[:bsdl_instr_name][start_index] = r0

        r0
      end

      def _nt_accessLink_genericID
        start_index = index
        if node_cache[:accessLink_genericID].has_key?(index)
          cached = node_cache[:accessLink_genericID][index]
          if cached
            node_cache[:accessLink_genericID][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_SCALAR_ID

        node_cache[:accessLink_genericID][start_index] = r0

        r0
      end

      def _nt_scanInterfaceChain_name
        start_index = index
        if node_cache[:scanInterfaceChain_name].has_key?(index)
          cached = node_cache[:scanInterfaceChain_name][index]
          if cached
            node_cache[:scanInterfaceChain_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_SCALAR_ID

        node_cache[:scanInterfaceChain_name][start_index] = r0

        r0
      end

      def _nt_scanInterface_name
        start_index = index
        if node_cache[:scanInterface_name].has_key?(index)
          cached = node_cache[:scanInterface_name][index]
          if cached
            node_cache[:scanInterface_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_SCALAR_ID

        node_cache[:scanInterface_name][start_index] = r0

        r0
      end

      def _nt_oneHotDataGroup_name
        start_index = index
        if node_cache[:oneHotDataGroup_name].has_key?(index)
          cached = node_cache[:oneHotDataGroup_name][index]
          if cached
            node_cache[:oneHotDataGroup_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_reg_port_signal_id

        node_cache[:oneHotDataGroup_name][start_index] = r0

        r0
      end

      def _nt_oneHotScanGroup_name
        start_index = index
        if node_cache[:oneHotScanGroup_name].has_key?(index)
          cached = node_cache[:oneHotScanGroup_name][index]
          if cached
            node_cache[:oneHotScanGroup_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_reg_port_signal_id

        node_cache[:oneHotScanGroup_name][start_index] = r0

        r0
      end

      def _nt_clockMux_name
        start_index = index
        if node_cache[:clockMux_name].has_key?(index)
          cached = node_cache[:clockMux_name][index]
          if cached
            node_cache[:clockMux_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_reg_port_signal_id

        node_cache[:clockMux_name][start_index] = r0

        r0
      end

      def _nt_clockMux_select
        start_index = index
        if node_cache[:clockMux_select].has_key?(index)
          cached = node_cache[:clockMux_select][index]
          if cached
            node_cache[:clockMux_select][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_concat_data_signal

        node_cache[:clockMux_select][start_index] = r0

        r0
      end

      def _nt_dataMux_name
        start_index = index
        if node_cache[:dataMux_name].has_key?(index)
          cached = node_cache[:dataMux_name][index]
          if cached
            node_cache[:dataMux_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_reg_port_signal_id

        node_cache[:dataMux_name][start_index] = r0

        r0
      end

      def _nt_dataMux_select
        start_index = index
        if node_cache[:dataMux_select].has_key?(index)
          cached = node_cache[:dataMux_select][index]
          if cached
            node_cache[:dataMux_select][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_concat_data_signal

        node_cache[:dataMux_select][start_index] = r0

        r0
      end

      def _nt_scanMux_name
        start_index = index
        if node_cache[:scanMux_name].has_key?(index)
          cached = node_cache[:scanMux_name][index]
          if cached
            node_cache[:scanMux_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_reg_port_signal_id

        node_cache[:scanMux_name][start_index] = r0

        r0
      end

      def _nt_scanMux_select
        start_index = index
        if node_cache[:scanMux_select].has_key?(index)
          cached = node_cache[:scanMux_select][index]
          if cached
            node_cache[:scanMux_select][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_concat_data_signal

        node_cache[:scanMux_select][start_index] = r0

        r0
      end

      def _nt_logicSignal_name
        start_index = index
        if node_cache[:logicSignal_name].has_key?(index)
          cached = node_cache[:logicSignal_name][index]
          if cached
            node_cache[:logicSignal_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_reg_port_signal_id

        node_cache[:logicSignal_name][start_index] = r0

        r0
      end

      def _nt_dataRegister_addressable
        start_index = index
        if node_cache[:dataRegister_addressable].has_key?(index)
          cached = node_cache[:dataRegister_addressable][index]
          if cached
            node_cache[:dataRegister_addressable][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_dataRegister_addressValue

        node_cache[:dataRegister_addressable][start_index] = r0

        r0
      end

      def _nt_dataRegister_name
        start_index = index
        if node_cache[:dataRegister_name].has_key?(index)
          cached = node_cache[:dataRegister_name][index]
          if cached
            node_cache[:dataRegister_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_register_name

        node_cache[:dataRegister_name][start_index] = r0

        r0
      end

      def _nt_scanRegister_name
        start_index = index
        if node_cache[:scanRegister_name].has_key?(index)
          cached = node_cache[:scanRegister_name][index]
          if cached
            node_cache[:scanRegister_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_register_name

        node_cache[:scanRegister_name][start_index] = r0

        r0
      end

      def _nt_parameter_override
        start_index = index
        if node_cache[:parameter_override].has_key?(index)
          cached = node_cache[:parameter_override][index]
          if cached
            node_cache[:parameter_override][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_parameter_def

        node_cache[:parameter_override][start_index] = r0

        r0
      end

      def _nt_inputPort_name
        start_index = index
        if node_cache[:inputPort_name].has_key?(index)
          cached = node_cache[:inputPort_name][index]
          if cached
            node_cache[:inputPort_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_port_name

        node_cache[:inputPort_name][start_index] = r0

        r0
      end

      def _nt_readEnPort_name
        start_index = index
        if node_cache[:readEnPort_name].has_key?(index)
          cached = node_cache[:readEnPort_name][index]
          if cached
            node_cache[:readEnPort_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_port_name

        node_cache[:readEnPort_name][start_index] = r0

        r0
      end

      def _nt_writeEnPort_name
        start_index = index
        if node_cache[:writeEnPort_name].has_key?(index)
          cached = node_cache[:writeEnPort_name][index]
          if cached
            node_cache[:writeEnPort_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_port_name

        node_cache[:writeEnPort_name][start_index] = r0

        r0
      end

      def _nt_addressPort_name
        start_index = index
        if node_cache[:addressPort_name].has_key?(index)
          cached = node_cache[:addressPort_name][index]
          if cached
            node_cache[:addressPort_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_port_name

        node_cache[:addressPort_name][start_index] = r0

        r0
      end

      def _nt_toTrstPort_name
        start_index = index
        if node_cache[:toTrstPort_name].has_key?(index)
          cached = node_cache[:toTrstPort_name][index]
          if cached
            node_cache[:toTrstPort_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_port_name

        node_cache[:toTrstPort_name][start_index] = r0

        r0
      end

      def _nt_trstPort_name
        start_index = index
        if node_cache[:trstPort_name].has_key?(index)
          cached = node_cache[:trstPort_name][index]
          if cached
            node_cache[:trstPort_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_port_name

        node_cache[:trstPort_name][start_index] = r0

        r0
      end

      def _nt_toClockPort_name
        start_index = index
        if node_cache[:toClockPort_name].has_key?(index)
          cached = node_cache[:toClockPort_name][index]
          if cached
            node_cache[:toClockPort_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_port_name

        node_cache[:toClockPort_name][start_index] = r0

        r0
      end

      def _nt_clockPort_name
        start_index = index
        if node_cache[:clockPort_name].has_key?(index)
          cached = node_cache[:clockPort_name][index]
          if cached
            node_cache[:clockPort_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_port_name

        node_cache[:clockPort_name][start_index] = r0

        r0
      end

      def _nt_toTckPort_name
        start_index = index
        if node_cache[:toTckPort_name].has_key?(index)
          cached = node_cache[:toTckPort_name][index]
          if cached
            node_cache[:toTckPort_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_port_name

        node_cache[:toTckPort_name][start_index] = r0

        r0
      end

      def _nt_tckPort_name
        start_index = index
        if node_cache[:tckPort_name].has_key?(index)
          cached = node_cache[:tckPort_name][index]
          if cached
            node_cache[:tckPort_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_port_name

        node_cache[:tckPort_name][start_index] = r0

        r0
      end

      def _nt_toIRSelectPort_name
        start_index = index
        if node_cache[:toIRSelectPort_name].has_key?(index)
          cached = node_cache[:toIRSelectPort_name][index]
          if cached
            node_cache[:toIRSelectPort_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_port_name

        node_cache[:toIRSelectPort_name][start_index] = r0

        r0
      end

      def _nt_toTmsPort_name
        start_index = index
        if node_cache[:toTmsPort_name].has_key?(index)
          cached = node_cache[:toTmsPort_name][index]
          if cached
            node_cache[:toTmsPort_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_port_name

        node_cache[:toTmsPort_name][start_index] = r0

        r0
      end

      def _nt_tmsPort_name
        start_index = index
        if node_cache[:tmsPort_name].has_key?(index)
          cached = node_cache[:tmsPort_name][index]
          if cached
            node_cache[:tmsPort_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_port_name

        node_cache[:tmsPort_name][start_index] = r0

        r0
      end

      def _nt_toResetPort_name
        start_index = index
        if node_cache[:toResetPort_name].has_key?(index)
          cached = node_cache[:toResetPort_name][index]
          if cached
            node_cache[:toResetPort_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_port_name

        node_cache[:toResetPort_name][start_index] = r0

        r0
      end

      def _nt_resetPort_name
        start_index = index
        if node_cache[:resetPort_name].has_key?(index)
          cached = node_cache[:resetPort_name][index]
          if cached
            node_cache[:resetPort_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_port_name

        node_cache[:resetPort_name][start_index] = r0

        r0
      end

      def _nt_toSelectPort_name
        start_index = index
        if node_cache[:toSelectPort_name].has_key?(index)
          cached = node_cache[:toSelectPort_name][index]
          if cached
            node_cache[:toSelectPort_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_port_name

        node_cache[:toSelectPort_name][start_index] = r0

        r0
      end

      def _nt_selectPort_name
        start_index = index
        if node_cache[:selectPort_name].has_key?(index)
          cached = node_cache[:selectPort_name][index]
          if cached
            node_cache[:selectPort_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_port_name

        node_cache[:selectPort_name][start_index] = r0

        r0
      end

      def _nt_toUpdateEnPort_name
        start_index = index
        if node_cache[:toUpdateEnPort_name].has_key?(index)
          cached = node_cache[:toUpdateEnPort_name][index]
          if cached
            node_cache[:toUpdateEnPort_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_port_name

        node_cache[:toUpdateEnPort_name][start_index] = r0

        r0
      end

      def _nt_toCaptureEnPort_name
        start_index = index
        if node_cache[:toCaptureEnPort_name].has_key?(index)
          cached = node_cache[:toCaptureEnPort_name][index]
          if cached
            node_cache[:toCaptureEnPort_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_port_name

        node_cache[:toCaptureEnPort_name][start_index] = r0

        r0
      end

      def _nt_toShiftEnPort_name
        start_index = index
        if node_cache[:toShiftEnPort_name].has_key?(index)
          cached = node_cache[:toShiftEnPort_name][index]
          if cached
            node_cache[:toShiftEnPort_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_port_name

        node_cache[:toShiftEnPort_name][start_index] = r0

        r0
      end

      def _nt_dataOutPort_name
        start_index = index
        if node_cache[:dataOutPort_name].has_key?(index)
          cached = node_cache[:dataOutPort_name][index]
          if cached
            node_cache[:dataOutPort_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_port_name

        node_cache[:dataOutPort_name][start_index] = r0

        r0
      end

      def _nt_dataInPort_name
        start_index = index
        if node_cache[:dataInPort_name].has_key?(index)
          cached = node_cache[:dataInPort_name][index]
          if cached
            node_cache[:dataInPort_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_port_name

        node_cache[:dataInPort_name][start_index] = r0

        r0
      end

      def _nt_updateEnPort_name
        start_index = index
        if node_cache[:updateEnPort_name].has_key?(index)
          cached = node_cache[:updateEnPort_name][index]
          if cached
            node_cache[:updateEnPort_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_port_name

        node_cache[:updateEnPort_name][start_index] = r0

        r0
      end

      def _nt_captureEnPort_name
        start_index = index
        if node_cache[:captureEnPort_name].has_key?(index)
          cached = node_cache[:captureEnPort_name][index]
          if cached
            node_cache[:captureEnPort_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_port_name

        node_cache[:captureEnPort_name][start_index] = r0

        r0
      end

      def _nt_shiftEnPort_name
        start_index = index
        if node_cache[:shiftEnPort_name].has_key?(index)
          cached = node_cache[:shiftEnPort_name][index]
          if cached
            node_cache[:shiftEnPort_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_port_name

        node_cache[:shiftEnPort_name][start_index] = r0

        r0
      end

      def _nt_scanInPort_name
        start_index = index
        if node_cache[:scanInPort_name].has_key?(index)
          cached = node_cache[:scanInPort_name][index]
          if cached
            node_cache[:scanInPort_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_port_name

        node_cache[:scanInPort_name][start_index] = r0

        r0
      end

      def _nt_scanOutPort_name
        start_index = index
        if node_cache[:scanOutPort_name].has_key?(index)
          cached = node_cache[:scanOutPort_name][index]
          if cached
            node_cache[:scanOutPort_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_port_name

        node_cache[:scanOutPort_name][start_index] = r0

        r0
      end

      module HierPort0
        def name
          elements[0]
        end

      end

      module HierPort1
        def ins
          elements[0]
        end

        def port
          elements[1]
        end

        def s
          elements[2]
        end
      end

      module HierPort2
        def to_ast
          n :hier_port, *ins.elements.map{ |e| e.name.to_ast }, port.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_hier_port
        start_index = index
        if node_cache[:hier_port].has_key?(index)
          cached = node_cache[:hier_port][index]
          if cached
            node_cache[:hier_port][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        s1, i1 = [], index
        loop do
          i2, s2 = index, []
          r3 = _nt_instance_name
          s2 << r3
          if r3
            if (match_len = has_terminal?(".", false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure('"."')
              r4 = nil
            end
            s2 << r4
          end
          if s2.last
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
            r2.extend(HierPort0)
          else
            @index = i2
            r2 = nil
          end
          if r2
            s1 << r2
          else
            break
          end
        end
        if s1.empty?
          @index = i1
          r1 = nil
        else
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        end
        s0 << r1
        if r1
          r5 = _nt_port_name
          s0 << r5
          if r5
            r6 = _nt_s
            s0 << r6
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(HierPort1)
          r0.extend(HierPort2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:hier_port][start_index] = r0

        r0
      end

      def _nt_port_name
        start_index = index
        if node_cache[:port_name].has_key?(index)
          cached = node_cache[:port_name][index]
          if cached
            node_cache[:port_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_vector_id
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_SCALAR_ID
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:port_name][start_index] = r0

        r0
      end

      def _nt_register_name
        start_index = index
        if node_cache[:register_name].has_key?(index)
          cached = node_cache[:register_name][index]
          if cached
            node_cache[:register_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_vector_id
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_SCALAR_ID
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:register_name][start_index] = r0

        r0
      end

      def _nt_instance_name
        start_index = index
        if node_cache[:instance_name].has_key?(index)
          cached = node_cache[:instance_name][index]
          if cached
            node_cache[:instance_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_SCALAR_ID

        node_cache[:instance_name][start_index] = r0

        r0
      end

      def _nt_namespace_name
        start_index = index
        if node_cache[:namespace_name].has_key?(index)
          cached = node_cache[:namespace_name][index]
          if cached
            node_cache[:namespace_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_SCALAR_ID

        node_cache[:namespace_name][start_index] = r0

        r0
      end

      def _nt_module_name
        start_index = index
        if node_cache[:module_name].has_key?(index)
          cached = node_cache[:module_name][index]
          if cached
            node_cache[:module_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_SCALAR_ID

        node_cache[:module_name][start_index] = r0

        r0
      end

      def _nt_reg_port_signal_id
        start_index = index
        if node_cache[:reg_port_signal_id].has_key?(index)
          cached = node_cache[:reg_port_signal_id][index]
          if cached
            node_cache[:reg_port_signal_id][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_vector_id
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_SCALAR_ID
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:reg_port_signal_id][start_index] = r0

        r0
      end

      def _nt_signal
        start_index = index
        if node_cache[:signal].has_key?(index)
          cached = node_cache[:signal][index]
          if cached
            node_cache[:signal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_hier_port
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_reg_port_signal_id
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_number
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:signal][start_index] = r0

        r0
      end

      module ResetSignal0
        def invert
          elements[0]
        end

        def val
          elements[1]
        end
      end

      module ResetSignal1

        def to_ast
          if !invert.empty?
            n :reset_signal, n(:invert), val.to_ast, input: input, interval: interval, file: file
          else
            n :reset_signal, val.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_reset_signal
        start_index = index
        if node_cache[:reset_signal].has_key?(index)
          cached = node_cache[:reset_signal][index]
          if cached
            node_cache[:reset_signal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?("~", false, index))
          r2 = true
          @index += match_len
        else
          terminal_parse_failure('"~"')
          r2 = nil
        end
        if r2
          r1 = r2
        else
          r1 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r1
        if r1
          r3 = _nt_signal
          s0 << r3
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ResetSignal0)
          r0.extend(ResetSignal1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:reset_signal][start_index] = r0

        r0
      end

      module ScanSignal0
        def invert
          elements[0]
        end

        def val
          elements[1]
        end
      end

      module ScanSignal1

        def to_ast
          if !invert.empty?
            n :scan_signal, n(:invert), val.to_ast, input: input, interval: interval, file: file
          else
            n :scan_signal, val.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_scan_signal
        start_index = index
        if node_cache[:scan_signal].has_key?(index)
          cached = node_cache[:scan_signal][index]
          if cached
            node_cache[:scan_signal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?("~", false, index))
          r2 = true
          @index += match_len
        else
          terminal_parse_failure('"~"')
          r2 = nil
        end
        if r2
          r1 = r2
        else
          r1 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r1
        if r1
          r3 = _nt_signal
          s0 << r3
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ScanSignal0)
          r0.extend(ScanSignal1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:scan_signal][start_index] = r0

        r0
      end

      module DataSignal0
        def invert
          elements[0]
        end

        def val
          elements[1]
        end
      end

      module DataSignal1

        def to_ast
          if !invert.empty?
            n :data_signal, n(:invert), val.to_ast, input: input, interval: interval, file: file
          else
            n :data_signal, val.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_data_signal
        start_index = index
        if node_cache[:data_signal].has_key?(index)
          cached = node_cache[:data_signal][index]
          if cached
            node_cache[:data_signal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?("~", false, index))
          r2 = true
          @index += match_len
        else
          terminal_parse_failure('"~"')
          r2 = nil
        end
        if r2
          r1 = r2
        else
          r1 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r1
        if r1
          r3 = _nt_signal
          s0 << r3
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DataSignal0)
          r0.extend(DataSignal1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:data_signal][start_index] = r0

        r0
      end

      module ClockSignal0
        def invert
          elements[0]
        end

        def val
          elements[1]
        end
      end

      module ClockSignal1

        def to_ast
          if !invert.empty?
            n :clock_signal, n(:invert), val.to_ast, input: input, interval: interval, file: file
          else
            n :clock_signal, val.to_ast, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_clock_signal
        start_index = index
        if node_cache[:clock_signal].has_key?(index)
          cached = node_cache[:clock_signal][index]
          if cached
            node_cache[:clock_signal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?("~", false, index))
          r2 = true
          @index += match_len
        else
          terminal_parse_failure('"~"')
          r2 = nil
        end
        if r2
          r1 = r2
        else
          r1 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r1
        if r1
          r3 = _nt_signal
          s0 << r3
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ClockSignal0)
          r0.extend(ClockSignal1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:clock_signal][start_index] = r0

        r0
      end

      def _nt_tck_signal
        start_index = index
        if node_cache[:tck_signal].has_key?(index)
          cached = node_cache[:tck_signal][index]
          if cached
            node_cache[:tck_signal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_signal

        node_cache[:tck_signal][start_index] = r0

        r0
      end

      def _nt_tms_signal
        start_index = index
        if node_cache[:tms_signal].has_key?(index)
          cached = node_cache[:tms_signal][index]
          if cached
            node_cache[:tms_signal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_signal

        node_cache[:tms_signal][start_index] = r0

        r0
      end

      def _nt_trst_signal
        start_index = index
        if node_cache[:trst_signal].has_key?(index)
          cached = node_cache[:trst_signal][index]
          if cached
            node_cache[:trst_signal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_signal

        node_cache[:trst_signal][start_index] = r0

        r0
      end

      def _nt_shiftEn_signal
        start_index = index
        if node_cache[:shiftEn_signal].has_key?(index)
          cached = node_cache[:shiftEn_signal][index]
          if cached
            node_cache[:shiftEn_signal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_signal

        node_cache[:shiftEn_signal][start_index] = r0

        r0
      end

      def _nt_captureEn_signal
        start_index = index
        if node_cache[:captureEn_signal].has_key?(index)
          cached = node_cache[:captureEn_signal][index]
          if cached
            node_cache[:captureEn_signal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_signal

        node_cache[:captureEn_signal][start_index] = r0

        r0
      end

      def _nt_updateEn_signal
        start_index = index
        if node_cache[:updateEn_signal].has_key?(index)
          cached = node_cache[:updateEn_signal][index]
          if cached
            node_cache[:updateEn_signal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_signal

        node_cache[:updateEn_signal][start_index] = r0

        r0
      end

      module ConcatResetSignal0
        def s1
          elements[0]
        end

        def s2
          elements[2]
        end

        def signal
          elements[3]
        end
      end

      module ConcatResetSignal1
        def s1
          elements[0]
        end

        def s2
          elements[1]
        end
      end

      module ConcatResetSignal2

        def to_ast
          if s2.empty?
            s1.to_ast
          else
            n :concat, s1.to_ast, *s2.elements.map{ |e| e.signal.to_ast }, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_concat_reset_signal
        start_index = index
        if node_cache[:concat_reset_signal].has_key?(index)
          cached = node_cache[:concat_reset_signal][index]
          if cached
            node_cache[:concat_reset_signal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        r2 = _nt_reset_signal
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          r3 = _nt_data_signal
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r1 = r3
          else
            @index = i1
            r1 = nil
          end
        end
        s0 << r1
        if r1
          s4, i4 = [], index
          loop do
            i5, s5 = index, []
            r6 = _nt_s
            s5 << r6
            if r6
              if (match_len = has_terminal?(",", false, index))
                r7 = true
                @index += match_len
              else
                terminal_parse_failure('","')
                r7 = nil
              end
              s5 << r7
              if r7
                r8 = _nt_s
                s5 << r8
                if r8
                  i9 = index
                  r10 = _nt_reset_signal
                  if r10
                    r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                    r9 = r10
                  else
                    r11 = _nt_data_signal
                    if r11
                      r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
                      r9 = r11
                    else
                      @index = i9
                      r9 = nil
                    end
                  end
                  s5 << r9
                end
              end
            end
            if s5.last
              r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
              r5.extend(ConcatResetSignal0)
            else
              @index = i5
              r5 = nil
            end
            if r5
              s4 << r5
            else
              break
            end
          end
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
          s0 << r4
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ConcatResetSignal1)
          r0.extend(ConcatResetSignal2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:concat_reset_signal][start_index] = r0

        r0
      end

      module ConcatScanSignal0
        def s1
          elements[0]
        end

        def s2
          elements[2]
        end

        def signal
          elements[3]
        end
      end

      module ConcatScanSignal1
        def s1
          elements[0]
        end

        def s2
          elements[1]
        end
      end

      module ConcatScanSignal2

        def to_ast
          if s2.empty?
            s1.to_ast
          else
            n :concat, s1.to_ast, *s2.elements.map{ |e| e.signal.to_ast }, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_concat_scan_signal
        start_index = index
        if node_cache[:concat_scan_signal].has_key?(index)
          cached = node_cache[:concat_scan_signal][index]
          if cached
            node_cache[:concat_scan_signal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        r2 = _nt_scan_signal
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          r3 = _nt_data_signal
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r1 = r3
          else
            @index = i1
            r1 = nil
          end
        end
        s0 << r1
        if r1
          s4, i4 = [], index
          loop do
            i5, s5 = index, []
            r6 = _nt_s
            s5 << r6
            if r6
              if (match_len = has_terminal?(",", false, index))
                r7 = true
                @index += match_len
              else
                terminal_parse_failure('","')
                r7 = nil
              end
              s5 << r7
              if r7
                r8 = _nt_s
                s5 << r8
                if r8
                  i9 = index
                  r10 = _nt_scan_signal
                  if r10
                    r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                    r9 = r10
                  else
                    r11 = _nt_data_signal
                    if r11
                      r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
                      r9 = r11
                    else
                      @index = i9
                      r9 = nil
                    end
                  end
                  s5 << r9
                end
              end
            end
            if s5.last
              r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
              r5.extend(ConcatScanSignal0)
            else
              @index = i5
              r5 = nil
            end
            if r5
              s4 << r5
            else
              break
            end
          end
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
          s0 << r4
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ConcatScanSignal1)
          r0.extend(ConcatScanSignal2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:concat_scan_signal][start_index] = r0

        r0
      end

      module ConcatDataSignal0
        def s1
          elements[0]
        end

        def s2
          elements[2]
        end

        def signal
          elements[3]
        end
      end

      module ConcatDataSignal1
        def s1
          elements[0]
        end

        def s2
          elements[1]
        end
      end

      module ConcatDataSignal2

        def to_ast
          if s2.empty?
            s1.to_ast
          else
            n :concat, s1.to_ast, *s2.elements.map{ |e| e.signal.to_ast }, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_concat_data_signal
        start_index = index
        if node_cache[:concat_data_signal].has_key?(index)
          cached = node_cache[:concat_data_signal][index]
          if cached
            node_cache[:concat_data_signal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_data_signal
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            r4 = _nt_s
            s3 << r4
            if r4
              if (match_len = has_terminal?(",", false, index))
                r5 = true
                @index += match_len
              else
                terminal_parse_failure('","')
                r5 = nil
              end
              s3 << r5
              if r5
                r6 = _nt_s
                s3 << r6
                if r6
                  r7 = _nt_data_signal
                  s3 << r7
                end
              end
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(ConcatDataSignal0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ConcatDataSignal1)
          r0.extend(ConcatDataSignal2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:concat_data_signal][start_index] = r0

        r0
      end

      module ConcatClockSignal0
        def s1
          elements[0]
        end

        def s2
          elements[2]
        end

        def signal
          elements[3]
        end
      end

      module ConcatClockSignal1
        def s1
          elements[0]
        end

        def s2
          elements[1]
        end
      end

      module ConcatClockSignal2

        def to_ast
          if s2.empty?
            s1.to_ast
          else
            n :concat, s1.to_ast, *s2.elements.map{ |e| e.signal.to_ast }, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_concat_clock_signal
        start_index = index
        if node_cache[:concat_clock_signal].has_key?(index)
          cached = node_cache[:concat_clock_signal][index]
          if cached
            node_cache[:concat_clock_signal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        r2 = _nt_clock_signal
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          r3 = _nt_data_signal
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r1 = r3
          else
            @index = i1
            r1 = nil
          end
        end
        s0 << r1
        if r1
          s4, i4 = [], index
          loop do
            i5, s5 = index, []
            r6 = _nt_s
            s5 << r6
            if r6
              if (match_len = has_terminal?(",", false, index))
                r7 = true
                @index += match_len
              else
                terminal_parse_failure('","')
                r7 = nil
              end
              s5 << r7
              if r7
                r8 = _nt_s
                s5 << r8
                if r8
                  i9 = index
                  r10 = _nt_clock_signal
                  if r10
                    r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                    r9 = r10
                  else
                    r11 = _nt_data_signal
                    if r11
                      r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
                      r9 = r11
                    else
                      @index = i9
                      r9 = nil
                    end
                  end
                  s5 << r9
                end
              end
            end
            if s5.last
              r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
              r5.extend(ConcatClockSignal0)
            else
              @index = i5
              r5 = nil
            end
            if r5
              s4 << r5
            else
              break
            end
          end
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
          s0 << r4
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ConcatClockSignal1)
          r0.extend(ConcatClockSignal2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:concat_clock_signal][start_index] = r0

        r0
      end

      module ConcatTckSignal0
        def s1
          elements[0]
        end

        def s2
          elements[2]
        end

        def signal
          elements[3]
        end
      end

      module ConcatTckSignal1
        def s1
          elements[0]
        end

        def s2
          elements[1]
        end
      end

      module ConcatTckSignal2

        def to_ast
          if s2.empty?
            s1.to_ast
          else
            n :concat, s1.to_ast, *s2.elements.map{ |e| e.signal.to_ast }, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_concat_tck_signal
        start_index = index
        if node_cache[:concat_tck_signal].has_key?(index)
          cached = node_cache[:concat_tck_signal][index]
          if cached
            node_cache[:concat_tck_signal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        r2 = _nt_tck_signal
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          r3 = _nt_data_signal
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r1 = r3
          else
            @index = i1
            r1 = nil
          end
        end
        s0 << r1
        if r1
          s4, i4 = [], index
          loop do
            i5, s5 = index, []
            r6 = _nt_s
            s5 << r6
            if r6
              if (match_len = has_terminal?(",", false, index))
                r7 = true
                @index += match_len
              else
                terminal_parse_failure('","')
                r7 = nil
              end
              s5 << r7
              if r7
                r8 = _nt_s
                s5 << r8
                if r8
                  i9 = index
                  r10 = _nt_tck_signal
                  if r10
                    r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                    r9 = r10
                  else
                    r11 = _nt_data_signal
                    if r11
                      r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
                      r9 = r11
                    else
                      @index = i9
                      r9 = nil
                    end
                  end
                  s5 << r9
                end
              end
            end
            if s5.last
              r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
              r5.extend(ConcatTckSignal0)
            else
              @index = i5
              r5 = nil
            end
            if r5
              s4 << r5
            else
              break
            end
          end
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
          s0 << r4
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ConcatTckSignal1)
          r0.extend(ConcatTckSignal2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:concat_tck_signal][start_index] = r0

        r0
      end

      module ConcatShiftEnSignal0
        def s1
          elements[0]
        end

        def s2
          elements[2]
        end

        def signal
          elements[3]
        end
      end

      module ConcatShiftEnSignal1
        def s1
          elements[0]
        end

        def s2
          elements[1]
        end
      end

      module ConcatShiftEnSignal2

        def to_ast
          if s2.empty?
            s1.to_ast
          else
            n :concat, s1.to_ast, *s2.elements.map{ |e| e.signal.to_ast }, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_concat_shiftEn_signal
        start_index = index
        if node_cache[:concat_shiftEn_signal].has_key?(index)
          cached = node_cache[:concat_shiftEn_signal][index]
          if cached
            node_cache[:concat_shiftEn_signal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        r2 = _nt_shiftEn_signal
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          r3 = _nt_data_signal
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r1 = r3
          else
            @index = i1
            r1 = nil
          end
        end
        s0 << r1
        if r1
          s4, i4 = [], index
          loop do
            i5, s5 = index, []
            r6 = _nt_s
            s5 << r6
            if r6
              if (match_len = has_terminal?(",", false, index))
                r7 = true
                @index += match_len
              else
                terminal_parse_failure('","')
                r7 = nil
              end
              s5 << r7
              if r7
                r8 = _nt_s
                s5 << r8
                if r8
                  i9 = index
                  r10 = _nt_shiftEn_signal
                  if r10
                    r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                    r9 = r10
                  else
                    r11 = _nt_data_signal
                    if r11
                      r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
                      r9 = r11
                    else
                      @index = i9
                      r9 = nil
                    end
                  end
                  s5 << r9
                end
              end
            end
            if s5.last
              r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
              r5.extend(ConcatShiftEnSignal0)
            else
              @index = i5
              r5 = nil
            end
            if r5
              s4 << r5
            else
              break
            end
          end
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
          s0 << r4
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ConcatShiftEnSignal1)
          r0.extend(ConcatShiftEnSignal2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:concat_shiftEn_signal][start_index] = r0

        r0
      end

      module ConcatCaptureEnSignal0
        def s1
          elements[0]
        end

        def s2
          elements[2]
        end

        def signal
          elements[3]
        end
      end

      module ConcatCaptureEnSignal1
        def s1
          elements[0]
        end

        def s2
          elements[1]
        end
      end

      module ConcatCaptureEnSignal2
        def to_ast
          if s2.empty?
            s1.to_ast
          else
            n :concat, s1.to_ast, *s2.elements.map{ |e| e.signal.to_ast }, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_concat_captureEn_signal
        start_index = index
        if node_cache[:concat_captureEn_signal].has_key?(index)
          cached = node_cache[:concat_captureEn_signal][index]
          if cached
            node_cache[:concat_captureEn_signal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        r2 = _nt_captureEn_signal
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          r3 = _nt_data_signal
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r1 = r3
          else
            @index = i1
            r1 = nil
          end
        end
        s0 << r1
        if r1
          s4, i4 = [], index
          loop do
            i5, s5 = index, []
            r6 = _nt_s
            s5 << r6
            if r6
              if (match_len = has_terminal?(",", false, index))
                r7 = true
                @index += match_len
              else
                terminal_parse_failure('","')
                r7 = nil
              end
              s5 << r7
              if r7
                r8 = _nt_s
                s5 << r8
                if r8
                  i9 = index
                  r10 = _nt_captureEn_signal
                  if r10
                    r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                    r9 = r10
                  else
                    r11 = _nt_data_signal
                    if r11
                      r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
                      r9 = r11
                    else
                      @index = i9
                      r9 = nil
                    end
                  end
                  s5 << r9
                end
              end
            end
            if s5.last
              r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
              r5.extend(ConcatCaptureEnSignal0)
            else
              @index = i5
              r5 = nil
            end
            if r5
              s4 << r5
            else
              break
            end
          end
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
          s0 << r4
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ConcatCaptureEnSignal1)
          r0.extend(ConcatCaptureEnSignal2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:concat_captureEn_signal][start_index] = r0

        r0
      end

      module ConcatTmsSignal0
        def signal
          elements[1]
        end
      end

      module ConcatTmsSignal1
        def s1
          elements[0]
        end

        def s2
          elements[1]
        end
      end

      module ConcatTmsSignal2

        def to_ast
          if s2.empty?
            s1.to_ast
          else
            n :concat, s1.to_ast, *s2.elements.map{ |e| e.signal.to_ast }, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_concat_tms_signal
        start_index = index
        if node_cache[:concat_tms_signal].has_key?(index)
          cached = node_cache[:concat_tms_signal][index]
          if cached
            node_cache[:concat_tms_signal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        r2 = _nt_tms_signal
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          r3 = _nt_data_signal
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r1 = r3
          else
            @index = i1
            r1 = nil
          end
        end
        s0 << r1
        if r1
          s4, i4 = [], index
          loop do
            i5, s5 = index, []
            if (match_len = has_terminal?(",", false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('","')
              r6 = nil
            end
            s5 << r6
            if r6
              i7 = index
              r8 = _nt_tms_signal
              if r8
                r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
                r7 = r8
              else
                r9 = _nt_data_signal
                if r9
                  r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
                  r7 = r9
                else
                  @index = i7
                  r7 = nil
                end
              end
              s5 << r7
            end
            if s5.last
              r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
              r5.extend(ConcatTmsSignal0)
            else
              @index = i5
              r5 = nil
            end
            if r5
              s4 << r5
            else
              break
            end
          end
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
          s0 << r4
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ConcatTmsSignal1)
          r0.extend(ConcatTmsSignal2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:concat_tms_signal][start_index] = r0

        r0
      end

      module ConcatTrstSignal0
        def signal
          elements[1]
        end
      end

      module ConcatTrstSignal1
        def s1
          elements[0]
        end

        def s2
          elements[1]
        end
      end

      module ConcatTrstSignal2

        def to_ast
          if s2.empty?
            s1.to_ast
          else
            n :concat, s1.to_ast, *s2.elements.map{ |e| e.signal.to_ast }, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_concat_trst_signal
        start_index = index
        if node_cache[:concat_trst_signal].has_key?(index)
          cached = node_cache[:concat_trst_signal][index]
          if cached
            node_cache[:concat_trst_signal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        r2 = _nt_trst_signal
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          r3 = _nt_data_signal
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r1 = r3
          else
            @index = i1
            r1 = nil
          end
        end
        s0 << r1
        if r1
          s4, i4 = [], index
          loop do
            i5, s5 = index, []
            if (match_len = has_terminal?(",", false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('","')
              r6 = nil
            end
            s5 << r6
            if r6
              i7 = index
              r8 = _nt_trst_signal
              if r8
                r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
                r7 = r8
              else
                r9 = _nt_data_signal
                if r9
                  r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
                  r7 = r9
                else
                  @index = i7
                  r7 = nil
                end
              end
              s5 << r7
            end
            if s5.last
              r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
              r5.extend(ConcatTrstSignal0)
            else
              @index = i5
              r5 = nil
            end
            if r5
              s4 << r5
            else
              break
            end
          end
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
          s0 << r4
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ConcatTrstSignal1)
          r0.extend(ConcatTrstSignal2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:concat_trst_signal][start_index] = r0

        r0
      end

      module SCALARID0
      end

      module SCALARID1
        def to_ast
          n :SCALAR_ID, text_value, input: input, interval: interval, file: file
        end
      end

      def _nt_SCALAR_ID
        start_index = index
        if node_cache[:SCALAR_ID].has_key?(index)
          cached = node_cache[:SCALAR_ID][index]
          if cached
            node_cache[:SCALAR_ID][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[a-zA-Z]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[a-zA-Z]')
          r1 = nil
        end
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3 = index
            if has_terminal?(@regexps[gr = '\A[a-zA-Z_]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[a-zA-Z_]')
              r4 = nil
            end
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r3 = r4
            else
              r5 = _nt_DEC_DIGIT
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r3 = r5
              else
                @index = i3
                r3 = nil
              end
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SCALARID0)
          r0.extend(SCALARID1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SCALAR_ID][start_index] = r0

        r0
      end

      module POSINT0
        def DEC_DIGIT
          elements[0]
        end

      end

      module POSINT1
        def to_ast
          n :POS_INT, text_value.sub("_", "").to_i, input: input, interval: interval, file: file
        end
      end

      def _nt_POS_INT
        start_index = index
        if node_cache[:POS_INT].has_key?(index)
          cached = node_cache[:POS_INT][index]
          if cached
            node_cache[:POS_INT][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_DEC_DIGIT
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3 = index
            if (match_len = has_terminal?('_', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure('\'_\'')
              r4 = nil
            end
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r3 = r4
            else
              r5 = _nt_DEC_DIGIT
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r3 = r5
              else
                @index = i3
                r3 = nil
              end
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(POSINT0)
          r0.extend(POSINT1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:POS_INT][start_index] = r0

        r0
      end

      def _nt_size
        start_index = index
        if node_cache[:size].has_key?(index)
          cached = node_cache[:size][index]
          if cached
            node_cache[:size][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_POS_INT
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_parameter_ref
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:size][start_index] = r0

        r0
      end

      module UNKNOWNDIGIT0
        def to_ast
          n :UNKNOWN_DIGIT, input: input, interval: interval, file: file
        end
      end

      def _nt_UNKNOWN_DIGIT
        start_index = index
        if node_cache[:UNKNOWN_DIGIT].has_key?(index)
          cached = node_cache[:UNKNOWN_DIGIT][index]
          if cached
            node_cache[:UNKNOWN_DIGIT][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        if (match_len = has_terminal?('X', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('\'X\'')
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          if (match_len = has_terminal?('x', false, index))
            r2 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            r2.extend(UNKNOWNDIGIT0)
            @index += match_len
          else
            terminal_parse_failure('\'x\'')
            r2 = nil
          end
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:UNKNOWN_DIGIT][start_index] = r0

        r0
      end

      def _nt_DEC_DIGIT
        start_index = index
        if node_cache[:DEC_DIGIT].has_key?(index)
          cached = node_cache[:DEC_DIGIT][index]
          if cached
            node_cache[:DEC_DIGIT][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
          r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('[0-9]')
          r0 = nil
        end

        node_cache[:DEC_DIGIT][start_index] = r0

        r0
      end

      def _nt_BIN_DIGIT
        start_index = index
        if node_cache[:BIN_DIGIT].has_key?(index)
          cached = node_cache[:BIN_DIGIT][index]
          if cached
            node_cache[:BIN_DIGIT][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        if has_terminal?(@regexps[gr = '\A[0-1]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[0-1]')
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_UNKNOWN_DIGIT
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:BIN_DIGIT][start_index] = r0

        r0
      end

      def _nt_HEX_DIGIT
        start_index = index
        if node_cache[:HEX_DIGIT].has_key?(index)
          cached = node_cache[:HEX_DIGIT][index]
          if cached
            node_cache[:HEX_DIGIT][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        if has_terminal?(@regexps[gr = '\A[0-9a-fA-F]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[0-9a-fA-F]')
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_UNKNOWN_DIGIT
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:HEX_DIGIT][start_index] = r0

        r0
      end

      module DECBASE0
      end

      def _nt_DEC_BASE
        start_index = index
        if node_cache[:DEC_BASE].has_key?(index)
          cached = node_cache[:DEC_BASE][index]
          if cached
            node_cache[:DEC_BASE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?("'", false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('"\'"')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          if (match_len = has_terminal?('d', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('\'d\'')
            r3 = nil
          end
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r2 = r3
          else
            if (match_len = has_terminal?('D', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure('\'D\'')
              r4 = nil
            end
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r2 = r4
            else
              @index = i2
              r2 = nil
            end
          end
          s0 << r2
          if r2
            s5, i5 = [], index
            loop do
              i6 = index
              if (match_len = has_terminal?(" ", false, index))
                r7 = true
                @index += match_len
              else
                terminal_parse_failure('" "')
                r7 = nil
              end
              if r7
                r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                r6 = r7
              else
                if (match_len = has_terminal?("\t", false, index))
                  r8 = true
                  @index += match_len
                else
                  terminal_parse_failure('"\\t"')
                  r8 = nil
                end
                if r8
                  r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
                  r6 = r8
                else
                  @index = i6
                  r6 = nil
                end
              end
              if r6
                s5 << r6
              else
                break
              end
            end
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            s0 << r5
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DECBASE0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:DEC_BASE][start_index] = r0

        r0
      end

      module BINBASE0
      end

      def _nt_BIN_BASE
        start_index = index
        if node_cache[:BIN_BASE].has_key?(index)
          cached = node_cache[:BIN_BASE][index]
          if cached
            node_cache[:BIN_BASE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?("'", false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('"\'"')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          if (match_len = has_terminal?('b', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('\'b\'')
            r3 = nil
          end
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r2 = r3
          else
            if (match_len = has_terminal?('B', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure('\'B\'')
              r4 = nil
            end
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r2 = r4
            else
              @index = i2
              r2 = nil
            end
          end
          s0 << r2
          if r2
            s5, i5 = [], index
            loop do
              i6 = index
              if (match_len = has_terminal?(" ", false, index))
                r7 = true
                @index += match_len
              else
                terminal_parse_failure('" "')
                r7 = nil
              end
              if r7
                r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                r6 = r7
              else
                if (match_len = has_terminal?("\t", false, index))
                  r8 = true
                  @index += match_len
                else
                  terminal_parse_failure('"\\t"')
                  r8 = nil
                end
                if r8
                  r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
                  r6 = r8
                else
                  @index = i6
                  r6 = nil
                end
              end
              if r6
                s5 << r6
              else
                break
              end
            end
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            s0 << r5
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(BINBASE0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:BIN_BASE][start_index] = r0

        r0
      end

      module HEXBASE0
      end

      def _nt_HEX_BASE
        start_index = index
        if node_cache[:HEX_BASE].has_key?(index)
          cached = node_cache[:HEX_BASE][index]
          if cached
            node_cache[:HEX_BASE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?("'", false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('"\'"')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          if (match_len = has_terminal?('h', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('\'h\'')
            r3 = nil
          end
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r2 = r3
          else
            if (match_len = has_terminal?('H', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure('\'H\'')
              r4 = nil
            end
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r2 = r4
            else
              @index = i2
              r2 = nil
            end
          end
          s0 << r2
          if r2
            s5, i5 = [], index
            loop do
              i6 = index
              if (match_len = has_terminal?(" ", false, index))
                r7 = true
                @index += match_len
              else
                terminal_parse_failure('" "')
                r7 = nil
              end
              if r7
                r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                r6 = r7
              else
                if (match_len = has_terminal?("\t", false, index))
                  r8 = true
                  @index += match_len
                else
                  terminal_parse_failure('"\\t"')
                  r8 = nil
                end
                if r8
                  r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
                  r6 = r8
                else
                  @index = i6
                  r6 = nil
                end
              end
              if r6
                s5 << r6
              else
                break
              end
            end
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            s0 << r5
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(HEXBASE0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:HEX_BASE][start_index] = r0

        r0
      end

      module UNSIZEDDECNUMBER0
        def DEC_BASE
          elements[0]
        end

        def val
          elements[1]
        end
      end

      module UNSIZEDDECNUMBER1
        def to_ast
          val.to_ast
        end
      end

      def _nt_UNSIZED_DEC_NUMBER
        start_index = index
        if node_cache[:UNSIZED_DEC_NUMBER].has_key?(index)
          cached = node_cache[:UNSIZED_DEC_NUMBER][index]
          if cached
            node_cache[:UNSIZED_DEC_NUMBER][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_DEC_BASE
        s0 << r1
        if r1
          r2 = _nt_POS_INT
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(UNSIZEDDECNUMBER0)
          r0.extend(UNSIZEDDECNUMBER1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:UNSIZED_DEC_NUMBER][start_index] = r0

        r0
      end

      module UNSIZEDBINNUMBER0
        def BIN_DIGIT
          elements[0]
        end

      end

      module UNSIZEDBINNUMBER1
        def BIN_BASE
          elements[0]
        end

        def val
          elements[1]
        end
      end

      module UNSIZEDBINNUMBER2
        def to_ast
          n :UNSIZED_BIN_NUMBER, val.text_value.sub("_", ""), input: input, interval: interval, file: file
        end
      end

      def _nt_UNSIZED_BIN_NUMBER
        start_index = index
        if node_cache[:UNSIZED_BIN_NUMBER].has_key?(index)
          cached = node_cache[:UNSIZED_BIN_NUMBER][index]
          if cached
            node_cache[:UNSIZED_BIN_NUMBER][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_BIN_BASE
        s0 << r1
        if r1
          i2, s2 = index, []
          r3 = _nt_BIN_DIGIT
          s2 << r3
          if r3
            s4, i4 = [], index
            loop do
              i5 = index
              if (match_len = has_terminal?("_", false, index))
                r6 = true
                @index += match_len
              else
                terminal_parse_failure('"_"')
                r6 = nil
              end
              if r6
                r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                r5 = r6
              else
                r7 = _nt_BIN_DIGIT
                if r7
                  r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                  r5 = r7
                else
                  @index = i5
                  r5 = nil
                end
              end
              if r5
                s4 << r5
              else
                break
              end
            end
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            s2 << r4
          end
          if s2.last
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
            r2.extend(UNSIZEDBINNUMBER0)
          else
            @index = i2
            r2 = nil
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(UNSIZEDBINNUMBER1)
          r0.extend(UNSIZEDBINNUMBER2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:UNSIZED_BIN_NUMBER][start_index] = r0

        r0
      end

      module UNSIZEDHEXNUMBER0
        def HEX_DIGIT
          elements[0]
        end

      end

      module UNSIZEDHEXNUMBER1
        def HEX_BASE
          elements[0]
        end

        def val
          elements[1]
        end
      end

      module UNSIZEDHEXNUMBER2
        def to_ast
          n :UNSIZED_HEX_NUMBER, val.text_value.sub("_", "").upcase, input: input, interval: interval, file: file
        end
      end

      def _nt_UNSIZED_HEX_NUMBER
        start_index = index
        if node_cache[:UNSIZED_HEX_NUMBER].has_key?(index)
          cached = node_cache[:UNSIZED_HEX_NUMBER][index]
          if cached
            node_cache[:UNSIZED_HEX_NUMBER][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_HEX_BASE
        s0 << r1
        if r1
          i2, s2 = index, []
          r3 = _nt_HEX_DIGIT
          s2 << r3
          if r3
            s4, i4 = [], index
            loop do
              i5 = index
              if (match_len = has_terminal?("_", false, index))
                r6 = true
                @index += match_len
              else
                terminal_parse_failure('"_"')
                r6 = nil
              end
              if r6
                r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                r5 = r6
              else
                r7 = _nt_HEX_DIGIT
                if r7
                  r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                  r5 = r7
                else
                  @index = i5
                  r5 = nil
                end
              end
              if r5
                s4 << r5
              else
                break
              end
            end
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            s2 << r4
          end
          if s2.last
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
            r2.extend(UNSIZEDHEXNUMBER0)
          else
            @index = i2
            r2 = nil
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(UNSIZEDHEXNUMBER1)
          r0.extend(UNSIZEDHEXNUMBER2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:UNSIZED_HEX_NUMBER][start_index] = r0

        r0
      end

      module SizedDecNumber0
        def v1
          elements[0]
        end

        def v2
          elements[1]
        end
      end

      module SizedDecNumber1
        def to_ast
          n :sized_dec_number, v1.to_ast, v2.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_sized_dec_number
        start_index = index
        if node_cache[:sized_dec_number].has_key?(index)
          cached = node_cache[:sized_dec_number][index]
          if cached
            node_cache[:sized_dec_number][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_size
        s0 << r1
        if r1
          r2 = _nt_UNSIZED_DEC_NUMBER
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SizedDecNumber0)
          r0.extend(SizedDecNumber1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:sized_dec_number][start_index] = r0

        r0
      end

      module SizedBinNumber0
        def v1
          elements[0]
        end

        def v2
          elements[1]
        end
      end

      module SizedBinNumber1
        def to_ast
          n :sized_bin_number, v1.to_ast, v2.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_sized_bin_number
        start_index = index
        if node_cache[:sized_bin_number].has_key?(index)
          cached = node_cache[:sized_bin_number][index]
          if cached
            node_cache[:sized_bin_number][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_size
        s0 << r1
        if r1
          r2 = _nt_UNSIZED_BIN_NUMBER
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SizedBinNumber0)
          r0.extend(SizedBinNumber1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:sized_bin_number][start_index] = r0

        r0
      end

      module SizedHexNumber0
        def v1
          elements[0]
        end

        def v2
          elements[1]
        end
      end

      module SizedHexNumber1
        def to_ast
          n :sized_hex_number, v1.to_ast, v2.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_sized_hex_number
        start_index = index
        if node_cache[:sized_hex_number].has_key?(index)
          cached = node_cache[:sized_hex_number][index]
          if cached
            node_cache[:sized_hex_number][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_size
        s0 << r1
        if r1
          r2 = _nt_UNSIZED_HEX_NUMBER
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SizedHexNumber0)
          r0.extend(SizedHexNumber1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:sized_hex_number][start_index] = r0

        r0
      end

      module VectorId0
        def name
          elements[0]
        end

        def val
          elements[2]
        end

      end

      module VectorId1
        def to_ast
          n :vector_id, name.to_ast, val.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_vector_id
        start_index = index
        if node_cache[:vector_id].has_key?(index)
          cached = node_cache[:vector_id][index]
          if cached
            node_cache[:vector_id][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SCALAR_ID
        s0 << r1
        if r1
          if (match_len = has_terminal?("[", false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('"["')
            r2 = nil
          end
          s0 << r2
          if r2
            i3 = index
            r4 = _nt_range
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r3 = r4
            else
              r5 = _nt_index
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r3 = r5
              else
                @index = i3
                r3 = nil
              end
            end
            s0 << r3
            if r3
              if (match_len = has_terminal?("]", false, index))
                r6 = true
                @index += match_len
              else
                terminal_parse_failure('"]"')
                r6 = nil
              end
              s0 << r6
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(VectorId0)
          r0.extend(VectorId1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:vector_id][start_index] = r0

        r0
      end

      def _nt_index
        start_index = index
        if node_cache[:index].has_key?(index)
          cached = node_cache[:index][index]
          if cached
            node_cache[:index][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_integer_expr

        node_cache[:index][start_index] = r0

        r0
      end

      module Range0
        def start
          elements[0]
        end

        def stop
          elements[2]
        end
      end

      module Range1
        def to_ast
          n :range, start.to_ast, stop.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_range
        start_index = index
        if node_cache[:range].has_key?(index)
          cached = node_cache[:range][index]
          if cached
            node_cache[:range][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_index
        s0 << r1
        if r1
          if (match_len = has_terminal?(":", false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('":"')
            r2 = nil
          end
          s0 << r2
          if r2
            r3 = _nt_index
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Range0)
          r0.extend(Range1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:range][start_index] = r0

        r0
      end

      def _nt_number
        start_index = index
        if node_cache[:number].has_key?(index)
          cached = node_cache[:number][index]
          if cached
            node_cache[:number][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_sized_number
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_unsized_number
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_integer_expr
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:number][start_index] = r0

        r0
      end

      module IntegerExpr0
        def expr
          elements[0]
        end
      end

      module IntegerExpr1
        def to_ast
          expr.to_ast
        end
      end

      def _nt_integer_expr
        start_index = index
        if node_cache[:integer_expr].has_key?(index)
          cached = node_cache[:integer_expr][index]
          if cached
            node_cache[:integer_expr][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_integer_expr_lvl1
        s0 << r1
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(IntegerExpr0)
          r0.extend(IntegerExpr1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:integer_expr][start_index] = r0

        r0
      end

      module IntegerExprLvl10
        def op
          elements[0]
        end

        def expr
          elements[1]
        end
      end

      module IntegerExprLvl11
        def left
          elements[0]
        end

        def right
          elements[1]
        end
      end

      module IntegerExprLvl12
        def to_ast
          if right.respond_to?(:op)
            if right.op.text_value == "+"
              n :add, left.to_ast, right.expr.to_ast, input: input, interval: interval, file: file
            else
              n :subtract, left.to_ast, right.expr.to_ast, input: input, interval: interval, file: file
            end
          else
            left.to_ast
          end
        end
      end

      def _nt_integer_expr_lvl1
        start_index = index
        if node_cache[:integer_expr_lvl1].has_key?(index)
          cached = node_cache[:integer_expr_lvl1][index]
          if cached
            node_cache[:integer_expr_lvl1][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_integer_expr_lvl2
        s0 << r1
        if r1
          i3, s3 = index, []
          i4 = index
          if (match_len = has_terminal?("+", false, index))
            r5 = true
            @index += match_len
          else
            terminal_parse_failure('"+"')
            r5 = nil
          end
          if r5
            r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
            r4 = r5
          else
            if (match_len = has_terminal?("-", false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('"-"')
              r6 = nil
            end
            if r6
              r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
              r4 = r6
            else
              @index = i4
              r4 = nil
            end
          end
          s3 << r4
          if r4
            r7 = _nt_integer_expr_lvl1
            s3 << r7
          end
          if s3.last
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            r3.extend(IntegerExprLvl10)
          else
            @index = i3
            r3 = nil
          end
          if r3
            r2 = r3
          else
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(IntegerExprLvl11)
          r0.extend(IntegerExprLvl12)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:integer_expr_lvl1][start_index] = r0

        r0
      end

      module IntegerExprLvl20
        def op
          elements[0]
        end

        def expr
          elements[1]
        end
      end

      module IntegerExprLvl21
        def left
          elements[0]
        end

        def right
          elements[1]
        end
      end

      module IntegerExprLvl22
        def to_ast
          if right.respond_to?(:op)
            if right.op.text_value == "*"
              n :multiply, left.to_ast, right.expr.to_ast, input: input, interval: interval, file: file
            elsif right.op.text_value == "/"
              n :divide, left.to_ast, right.expr.to_ast, input: input, interval: interval, file: file
            else
              n :modulus, left.to_ast, right.expr.to_ast, input: input, interval: interval, file: file
            end
          else
            left.to_ast
          end
        end
      end

      def _nt_integer_expr_lvl2
        start_index = index
        if node_cache[:integer_expr_lvl2].has_key?(index)
          cached = node_cache[:integer_expr_lvl2][index]
          if cached
            node_cache[:integer_expr_lvl2][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_integer_expr_arg
        s0 << r1
        if r1
          i3, s3 = index, []
          i4 = index
          if (match_len = has_terminal?("*", false, index))
            r5 = true
            @index += match_len
          else
            terminal_parse_failure('"*"')
            r5 = nil
          end
          if r5
            r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
            r4 = r5
          else
            if (match_len = has_terminal?("/", false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('"/"')
              r6 = nil
            end
            if r6
              r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
              r4 = r6
            else
              if (match_len = has_terminal?("%", false, index))
                r7 = true
                @index += match_len
              else
                terminal_parse_failure('"%"')
                r7 = nil
              end
              if r7
                r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                r4 = r7
              else
                @index = i4
                r4 = nil
              end
            end
          end
          s3 << r4
          if r4
            r8 = _nt_integer_expr_lvl2
            s3 << r8
          end
          if s3.last
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            r3.extend(IntegerExprLvl20)
          else
            @index = i3
            r3 = nil
          end
          if r3
            r2 = r3
          else
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(IntegerExprLvl21)
          r0.extend(IntegerExprLvl22)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:integer_expr_lvl2][start_index] = r0

        r0
      end

      module IntegerExprParen0
        def expr
          elements[1]
        end

      end

      module IntegerExprParen1
        def to_ast
          expr.to_ast
        end
      end

      def _nt_integer_expr_paren
        start_index = index
        if node_cache[:integer_expr_paren].has_key?(index)
          cached = node_cache[:integer_expr_paren][index]
          if cached
            node_cache[:integer_expr_paren][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?("(", false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('"("')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_integer_expr
          s0 << r2
          if r2
            if (match_len = has_terminal?(")", false, index))
              r3 = true
              @index += match_len
            else
              terminal_parse_failure('")"')
              r3 = nil
            end
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(IntegerExprParen0)
          r0.extend(IntegerExprParen1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:integer_expr_paren][start_index] = r0

        r0
      end

      def _nt_integer_expr_arg
        start_index = index
        if node_cache[:integer_expr_arg].has_key?(index)
          cached = node_cache[:integer_expr_arg][index]
          if cached
            node_cache[:integer_expr_arg][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_parameter_ref
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_integer_expr_paren
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_POS_INT
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:integer_expr_arg][start_index] = r0

        r0
      end

      def _nt_logic_expr
        start_index = index
        if node_cache[:logic_expr].has_key?(index)
          cached = node_cache[:logic_expr][index]
          if cached
            node_cache[:logic_expr][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_logic_expr_lvl1

        node_cache[:logic_expr][start_index] = r0

        r0
      end

      module LogicExprLvl10
        def logic_expr_lvl1
          elements[1]
        end
      end

      module LogicExprLvl11
        def logic_expr_lvl2
          elements[0]
        end

      end

      def _nt_logic_expr_lvl1
        start_index = index
        if node_cache[:logic_expr_lvl1].has_key?(index)
          cached = node_cache[:logic_expr_lvl1][index]
          if cached
            node_cache[:logic_expr_lvl1][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_logic_expr_lvl2
        s0 << r1
        if r1
          i3, s3 = index, []
          i4 = index
          if (match_len = has_terminal?('&&', false, index))
            r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'&&\'')
            r5 = nil
          end
          if r5
            r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
            r4 = r5
          else
            if (match_len = has_terminal?('||', false, index))
              r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('\'||\'')
              r6 = nil
            end
            if r6
              r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
              r4 = r6
            else
              @index = i4
              r4 = nil
            end
          end
          s3 << r4
          if r4
            r7 = _nt_logic_expr_lvl1
            s3 << r7
          end
          if s3.last
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            r3.extend(LogicExprLvl10)
          else
            @index = i3
            r3 = nil
          end
          if r3
            r2 = r3
          else
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(LogicExprLvl11)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:logic_expr_lvl1][start_index] = r0

        r0
      end

      module LogicExprLvl20
        def logic_expr_lvl2
          elements[1]
        end
      end

      module LogicExprLvl21
        def logic_expr_lvl3
          elements[0]
        end

      end

      module LogicExprLvl22
        def logic_expr_lvl2
          elements[1]
        end
      end

      def _nt_logic_expr_lvl2
        start_index = index
        if node_cache[:logic_expr_lvl2].has_key?(index)
          cached = node_cache[:logic_expr_lvl2][index]
          if cached
            node_cache[:logic_expr_lvl2][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_logic_expr_lvl3
        s1 << r2
        if r2
          i4, s4 = index, []
          i5 = index
          if (match_len = has_terminal?('&', false, index))
            r6 = true
            @index += match_len
          else
            terminal_parse_failure('\'&\'')
            r6 = nil
          end
          if r6
            r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
            r5 = r6
          else
            if (match_len = has_terminal?('|', false, index))
              r7 = true
              @index += match_len
            else
              terminal_parse_failure('\'|\'')
              r7 = nil
            end
            if r7
              r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
              r5 = r7
            else
              if (match_len = has_terminal?('^', false, index))
                r8 = true
                @index += match_len
              else
                terminal_parse_failure('\'^\'')
                r8 = nil
              end
              if r8
                r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
                r5 = r8
              else
                @index = i5
                r5 = nil
              end
            end
          end
          s4 << r5
          if r5
            r9 = _nt_logic_expr_lvl2
            s4 << r9
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(LogicExprLvl20)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r3 = r4
          else
            r3 = instantiate_node(SyntaxNode,input, index...index)
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(LogicExprLvl21)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i10, s10 = index, []
          i11 = index
          if (match_len = has_terminal?('&', false, index))
            r12 = true
            @index += match_len
          else
            terminal_parse_failure('\'&\'')
            r12 = nil
          end
          if r12
            r12 = SyntaxNode.new(input, (index-1)...index) if r12 == true
            r11 = r12
          else
            if (match_len = has_terminal?('|', false, index))
              r13 = true
              @index += match_len
            else
              terminal_parse_failure('\'|\'')
              r13 = nil
            end
            if r13
              r13 = SyntaxNode.new(input, (index-1)...index) if r13 == true
              r11 = r13
            else
              if (match_len = has_terminal?('^', false, index))
                r14 = true
                @index += match_len
              else
                terminal_parse_failure('\'^\'')
                r14 = nil
              end
              if r14
                r14 = SyntaxNode.new(input, (index-1)...index) if r14 == true
                r11 = r14
              else
                @index = i11
                r11 = nil
              end
            end
          end
          s10 << r11
          if r11
            r15 = _nt_logic_expr_lvl2
            s10 << r15
          end
          if s10.last
            r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
            r10.extend(LogicExprLvl22)
          else
            @index = i10
            r10 = nil
          end
          if r10
            r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
            r0 = r10
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:logic_expr_lvl2][start_index] = r0

        r0
      end

      module LogicExprLvl30
        def logic_expr_num_arg
          elements[1]
        end
      end

      module LogicExprLvl31
        def logic_expr_lvl4
          elements[0]
        end

      end

      def _nt_logic_expr_lvl3
        start_index = index
        if node_cache[:logic_expr_lvl3].has_key?(index)
          cached = node_cache[:logic_expr_lvl3][index]
          if cached
            node_cache[:logic_expr_lvl3][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_logic_expr_lvl4
        s0 << r1
        if r1
          i3, s3 = index, []
          i4 = index
          if (match_len = has_terminal?('==', false, index))
            r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'==\'')
            r5 = nil
          end
          if r5
            r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
            r4 = r5
          else
            if (match_len = has_terminal?('!=', false, index))
              r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('\'!=\'')
              r6 = nil
            end
            if r6
              r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
              r4 = r6
            else
              @index = i4
              r4 = nil
            end
          end
          s3 << r4
          if r4
            r7 = _nt_logic_expr_num_arg
            s3 << r7
          end
          if s3.last
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            r3.extend(LogicExprLvl30)
          else
            @index = i3
            r3 = nil
          end
          if r3
            r2 = r3
          else
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(LogicExprLvl31)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:logic_expr_lvl3][start_index] = r0

        r0
      end

      module LogicExprLvl40
        def logic_expr_lvl4
          elements[1]
        end
      end

      module LogicExprLvl41
        def logic_expr_arg
          elements[0]
        end

      end

      def _nt_logic_expr_lvl4
        start_index = index
        if node_cache[:logic_expr_lvl4].has_key?(index)
          cached = node_cache[:logic_expr_lvl4][index]
          if cached
            node_cache[:logic_expr_lvl4][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_logic_expr_arg
        s0 << r1
        if r1
          i3, s3 = index, []
          if (match_len = has_terminal?(',', false, index))
            r4 = true
            @index += match_len
          else
            terminal_parse_failure('\',\'')
            r4 = nil
          end
          s3 << r4
          if r4
            r5 = _nt_logic_expr_lvl4
            s3 << r5
          end
          if s3.last
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            r3.extend(LogicExprLvl40)
          else
            @index = i3
            r3 = nil
          end
          if r3
            r2 = r3
          else
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(LogicExprLvl41)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:logic_expr_lvl4][start_index] = r0

        r0
      end

      module LogicUnaryExpr0
        def logic_expr_arg
          elements[1]
        end
      end

      def _nt_logic_unary_expr
        start_index = index
        if node_cache[:logic_unary_expr].has_key?(index)
          cached = node_cache[:logic_unary_expr][index]
          if cached
            node_cache[:logic_unary_expr][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        if (match_len = has_terminal?('~', false, index))
          r2 = true
          @index += match_len
        else
          terminal_parse_failure('\'~\'')
          r2 = nil
        end
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          if (match_len = has_terminal?('!', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('\'!\'')
            r3 = nil
          end
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r1 = r3
          else
            @index = i1
            r1 = nil
          end
        end
        s0 << r1
        if r1
          r4 = _nt_logic_expr_arg
          s0 << r4
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(LogicUnaryExpr0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:logic_unary_expr][start_index] = r0

        r0
      end

      module LogicExprParen0
        def s1
          elements[1]
        end

        def logic_expr
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      def _nt_logic_expr_paren
        start_index = index
        if node_cache[:logic_expr_paren].has_key?(index)
          cached = node_cache[:logic_expr_paren][index]
          if cached
            node_cache[:logic_expr_paren][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('(', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('\'(\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            r3 = _nt_logic_expr
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?(')', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\')\'')
                  r5 = nil
                end
                s0 << r5
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(LogicExprParen0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:logic_expr_paren][start_index] = r0

        r0
      end

      def _nt_logic_expr_arg
        start_index = index
        if node_cache[:logic_expr_arg].has_key?(index)
          cached = node_cache[:logic_expr_arg][index]
          if cached
            node_cache[:logic_expr_arg][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_logic_expr_paren
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_logic_unary_expr
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_concat_data_signal
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:logic_expr_arg][start_index] = r0

        r0
      end

      module LogicExprNumArg0
        def s1
          elements[1]
        end

        def logic_expr_num_arg
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      def _nt_logic_expr_num_arg
        start_index = index
        if node_cache[:logic_expr_num_arg].has_key?(index)
          cached = node_cache[:logic_expr_num_arg][index]
          if cached
            node_cache[:logic_expr_num_arg][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_concat_number
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_enum_name
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            i3, s3 = index, []
            if (match_len = has_terminal?('(', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure('\'(\'')
              r4 = nil
            end
            s3 << r4
            if r4
              r5 = _nt_s
              s3 << r5
              if r5
                r6 = _nt_logic_expr_num_arg
                s3 << r6
                if r6
                  r7 = _nt_s
                  s3 << r7
                  if r7
                    if (match_len = has_terminal?(')', false, index))
                      r8 = true
                      @index += match_len
                    else
                      terminal_parse_failure('\')\'')
                      r8 = nil
                    end
                    s3 << r8
                  end
                end
              end
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(LogicExprNumArg0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:logic_expr_num_arg][start_index] = r0

        r0
      end

      module ParameterRef0
        def id
          elements[1]
        end
      end

      module ParameterRef1
        def to_ast
          n :parameter_ref, id.to_ast, input: input, interval: interval, file: file
        end
      end

      def _nt_parameter_ref
        start_index = index
        if node_cache[:parameter_ref].has_key?(index)
          cached = node_cache[:parameter_ref][index]
          if cached
            node_cache[:parameter_ref][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?("$", false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('"$"')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_SCALAR_ID
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ParameterRef0)
          r0.extend(ParameterRef1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:parameter_ref][start_index] = r0

        r0
      end

      def _nt_unsized_number
        start_index = index
        if node_cache[:unsized_number].has_key?(index)
          cached = node_cache[:unsized_number][index]
          if cached
            node_cache[:unsized_number][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_UNSIZED_DEC_NUMBER
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_UNSIZED_BIN_NUMBER
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_UNSIZED_HEX_NUMBER
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              r4 = _nt_POS_INT
              if r4
                r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
                r0 = r4
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end

        node_cache[:unsized_number][start_index] = r0

        r0
      end

      def _nt_sized_number
        start_index = index
        if node_cache[:sized_number].has_key?(index)
          cached = node_cache[:sized_number][index]
          if cached
            node_cache[:sized_number][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_sized_dec_number
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_sized_bin_number
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_sized_hex_number
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:sized_number][start_index] = r0

        r0
      end

      module ConcatNumber0
        def val
          elements[2]
        end
      end

      module ConcatNumber1
        def invert
          elements[0]
        end

        def s1
          elements[1]
        end

        def s2
          elements[2]
        end
      end

      module ConcatNumber2
        def to_ast
          fail "concat_number invert not handled yet!" unless invert.empty?
          if s2.empty?
            s1.to_ast
          else
            n :concat, s1.to_ast, *s2.elements.map{ |e| e.val.to_ast }, input: input, interval: interval, file: file
          end
        end
      end

      def _nt_concat_number
        start_index = index
        if node_cache[:concat_number].has_key?(index)
          cached = node_cache[:concat_number][index]
          if cached
            node_cache[:concat_number][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?("~", false, index))
          r2 = true
          @index += match_len
        else
          terminal_parse_failure('"~"')
          r2 = nil
        end
        if r2
          r1 = r2
        else
          r1 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r1
        if r1
          r3 = _nt_number
          s0 << r3
          if r3
            s4, i4 = [], index
            loop do
              i5, s5 = index, []
              if (match_len = has_terminal?(",", false, index))
                r6 = true
                @index += match_len
              else
                terminal_parse_failure('","')
                r6 = nil
              end
              s5 << r6
              if r6
                if (match_len = has_terminal?("~", false, index))
                  r8 = true
                  @index += match_len
                else
                  terminal_parse_failure('"~"')
                  r8 = nil
                end
                if r8
                  r7 = r8
                else
                  r7 = instantiate_node(SyntaxNode,input, index...index)
                end
                s5 << r7
                if r7
                  r9 = _nt_number
                  s5 << r9
                end
              end
              if s5.last
                r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
                r5.extend(ConcatNumber0)
              else
                @index = i5
                r5 = nil
              end
              if r5
                s4 << r5
              else
                break
              end
            end
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            s0 << r4
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ConcatNumber1)
          r0.extend(ConcatNumber2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:concat_number][start_index] = r0

        r0
      end

      module ConcatNumberList0
        def concat_number
          elements[1]
        end
      end

      module ConcatNumberList1
        def concat_number
          elements[0]
        end

      end

      def _nt_concat_number_list
        start_index = index
        if node_cache[:concat_number_list].has_key?(index)
          cached = node_cache[:concat_number_list][index]
          if cached
            node_cache[:concat_number_list][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_concat_number
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            if (match_len = has_terminal?("|", false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure('"|"')
              r4 = nil
            end
            s3 << r4
            if r4
              r5 = _nt_concat_number
              s3 << r5
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(ConcatNumberList0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ConcatNumberList1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:concat_number_list][start_index] = r0

        r0
      end

      def _nt_s
        start_index = index
        if node_cache[:s].has_key?(index)
          cached = node_cache[:s][index]
          if cached
            node_cache[:s][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          i1 = index
          if (match_len = has_terminal?(" ", false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('" "')
            r2 = nil
          end
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r1 = r2
          else
            if (match_len = has_terminal?("\t", false, index))
              r3 = true
              @index += match_len
            else
              terminal_parse_failure('"\\t"')
              r3 = nil
            end
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r1 = r3
            else
              r4 = _nt_N
              if r4
                r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
                r1 = r4
              else
                r5 = _nt_sl_comment
                if r5
                  r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                  r1 = r5
                else
                  r6 = _nt_ml_comment
                  if r6
                    r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                    r1 = r6
                  else
                    @index = i1
                    r1 = nil
                  end
                end
              end
            end
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)

        node_cache[:s][start_index] = r0

        r0
      end

      def _nt_S
        start_index = index
        if node_cache[:S].has_key?(index)
          cached = node_cache[:S][index]
          if cached
            node_cache[:S][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          i1 = index
          if (match_len = has_terminal?(" ", false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('" "')
            r2 = nil
          end
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r1 = r2
          else
            if (match_len = has_terminal?("\t", false, index))
              r3 = true
              @index += match_len
            else
              terminal_parse_failure('"\\t"')
              r3 = nil
            end
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r1 = r3
            else
              r4 = _nt_N
              if r4
                r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
                r1 = r4
              else
                r5 = _nt_sl_comment
                if r5
                  r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                  r1 = r5
                else
                  r6 = _nt_ml_comment
                  if r6
                    r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                    r1 = r6
                  else
                    @index = i1
                    r1 = nil
                  end
                end
              end
            end
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        end

        node_cache[:S][start_index] = r0

        r0
      end

      module N0
      end

      def _nt_n
        start_index = index
        if node_cache[:n].has_key?(index)
          cached = node_cache[:n][index]
          if cached
            node_cache[:n][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?("\r", false, index))
          r2 = true
          @index += match_len
        else
          terminal_parse_failure('"\\r"')
          r2 = nil
        end
        if r2
          r1 = r2
        else
          r1 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r1
        if r1
          if (match_len = has_terminal?("\n", false, index))
            r4 = true
            @index += match_len
          else
            terminal_parse_failure('"\\n"')
            r4 = nil
          end
          if r4
            r3 = r4
          else
            r3 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r3
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(N0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:n][start_index] = r0

        r0
      end

      module N0
      end

      def _nt_N
        start_index = index
        if node_cache[:N].has_key?(index)
          cached = node_cache[:N][index]
          if cached
            node_cache[:N][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?("\r", false, index))
          r2 = true
          @index += match_len
        else
          terminal_parse_failure('"\\r"')
          r2 = nil
        end
        if r2
          r1 = r2
        else
          r1 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r1
        if r1
          if (match_len = has_terminal?("\n", false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('"\\n"')
            r3 = nil
          end
          s0 << r3
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(N0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:N][start_index] = r0

        r0
      end

    end

    class GrammarParser < Treetop::Runtime::CompiledParser
      include Grammar
    end

  end
end
