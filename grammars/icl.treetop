module IJTAG
  module ICL
    grammar Grammar
      rule icl_source
        iclSource_items+ {
          def to_ast
            n :icl_source, *elements.map{ |e| e.to_ast if e.respond_to?(:to_ast) }.compact
          end
        }
      end

      rule iclSource_items
        S / ml_comment / sl_comment / nameSpace_def / useNameSpace_def / module_def
      end

      ####################################################
      # TOP LEVEL NODES
      ####################################################

      rule ml_comment
        "/*" (!end_of_comment .)* end_of_comment s
      end

      rule end_of_comment
        "*/"
      end

      rule sl_comment
        "//" (!N .)* s
      end

      rule nameSpace_def
        "NameSpace" s name:namespace_name? s ";" s {
          def to_ast
            n1 :nameSpace_def, name.to_ast
          end
        }
      end

      rule useNameSpace_def
        "UseNameSpace" s name:namespace_name? s ";" s {
          def to_ast
            n1 :useNameSpace_def, name.to_ast
          end
        }
      end

      rule module_def
        "Module" S name:module_name S "{" s items:module_item* s "}" s {
          def to_ast
            if respond_to?(:items)
              n :module_def, name.to_ast, *items.elements.map{ |e| e.to_ast }
            else
              n :module_def, name.to_ast
            end
          end
        }
      end

      rule module_item
        useNameSpace_def /
        port_def /
        instance_def /
        scanRegister_def /
        dataRegister_def /
        logicSignal_def /
        scanMux_def /
        dataMux_def /
        clockMux_def /
        oneHotDataGroup_def /
        oneHotScanGroup_def /
        scanInterface_def /
        accessLink_def /
        alias_def /
        enum_def /
        parameter_def /
        localParameter_def /
        attribute_def
      end

      rule port_def
        scanInPort_def /
        scanOutPort_def /
        shiftEnPort_def /
        captureEnPort_def /
        updateEnPort_def /
        dataInPort_def /
        dataOutPort_def /
        toShiftEnPort_def /
        toUpdateEnPort_def /
        toCaptureEnPort_def /
        selectPort_def /
        toSelectPort_def /
        resetPort_def /
        toResetPort_def /
        tmsPort_def /
        toTmsPort_def /
        tckPort_def /
        toTckPort_def /
        clockPort_def /
        toClockPort_def /
        trstPort_def /
        toTrstPort_def /
        toIRSelectPort_def /
        addressPort_def /
        writeEnPort_def /
        readEnPort_def
      end

      ####################################################
      # INTERMEDIATE NODES
      ####################################################

      rule scanInPort_def
        'ScanInPort' S name:scanInPort_name s d:(';' / ('{' s attrs:attribute_def* s '}')) s {
          def to_ast
            if d.respond_to?(:attrs)
              n :scanInPort_def, name.to_ast, *d.attrs.elements.map{ |e| e.to_ast }
            else
              n :scanInPort_def, name.to_ast
            end
          end
        }
      end

      rule scanOutPort_def
        'ScanOutPort' S name:scanOutPort_name s d:(';' / ('{' s items:scanOutPort_item* s '}')) s {
          def to_ast
            if d.respond_to?(:items)
              n :scanOutPort_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }
            else
              n :scanOutPort_def, name.to_ast
            end
          end
        }
      end

      rule scanOutPort_item 
        attribute_def / scanOutPort_source / scanOutPort_enable
      end

      rule scanOutPort_source
        'Source' S signal:concat_scan_signal s ';' s {
          def to_ast
            n :source, signal.to_ast
          end
        }
      end

      rule scanOutPort_enable
        'Enable' S signal:data_signal s ';' s {
          def to_ast
            n :enable, signal.to_ast
          end
        }
      end

      rule shiftEnPort_def
        'ShiftEnPort' S name:shiftEnPort_name s d:(';' / ('{' s attrs:attribute_def* s '}')) s {
          def to_ast
            if d.respond_to?(:attrs)
              n :shiftEnPort_def, name.to_ast, *d.attrs.elements.map{ |e| e.to_ast }
            else
              n :shiftEnPort_def, name.to_ast
            end
          end
        }
      end

      rule captureEnPort_def
        'CaptureEnPort' S name:captureEnPort_name s d:(';' / ('{' s attrs:attribute_def* s '}')) s {
          def to_ast
            if d.respond_to?(:attrs)
              n :captureEnPort_def, name.to_ast, *d.attrs.elements.map{ |e| e.to_ast }
            else
              n :captureEnPort_def, name.to_ast
            end
          end
        }
      end

      rule updateEnPort_def
        'UpdateEnPort' S name:updateEnPort_name s d:(';' / ('{' s attrs:attribute_def* s '}')) s {
          def to_ast
            if d.respond_to?(:attrs)
              n :updateEnPort_def, name.to_ast, *d.attrs.elements.map{ |e| e.to_ast }
            else
              n :updateEnPort_def, name.to_ast
            end
          end
        }
      end

      rule dataInPort_def
        'DataInPort' S name:dataInPort_name s d:(';' / ('{' s items:dataInPort_item* s '}')) s {
          def to_ast
            if d.respond_to?(:items)
              n :dataInPort_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }
            else
              n :dataInPort_def, name.to_ast
            end
          end
        }
      end
     
      rule dataInPort_item
        attribute_def /
        dataInPort_refEnum /
        dataInPort_defaultLoadValue
      end

      rule dataInPort_refEnum
        'RefEnum' s name:enum_name s ';' s {
          def to_ast
            n :refEnum, name.to_ast
          end
        }
      end

      rule dataInPort_defaultLoadValue
        'DefaultLoadValue' S val:(concat_number / enum_symbol) s ';' s {
          def to_ast
            n :dataInPort_defaultLoadValue, val.to_ast
          end
        }
      end

      rule dataOutPort_def
        'DataOutPort' S name:dataOutPort_name s d:(';' / ('{' s items:dataOutPort_item*  s '}')) s {
          def to_ast
            if d.respond_to?(:items)
              n :dataOutPort_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }
            else
              n :dataOutPort_def, name.to_ast
            end
          end
        }
      end

      rule dataOutPort_item
        attribute_def /
        dataOutPort_source /
        dataOutPort_enable /
        dataOutPort_refEnum
      end

      rule dataOutPort_source
        'Source' S signal:concat_data_signal s ';' s {
          def to_ast
            n :source, signal.to_ast
          end
        }
      end

      rule dataOutPort_enable
        'Enable' S signal:data_signal s ';' s {
          def to_ast
            n :enable, signal.to_ast
          end
        }
      end

      rule dataOutPort_refEnum
        'RefEnum' S name:enum_name s ';' s {
          def to_ast
            n :refEnum, name.to_ast
          end
        }
      end

      rule toShiftEnPort_def
        'ToShiftEnPort' S name:toShiftEnPort_name s d:(';' / ('{' s items:toShiftEnPort_items* s '}')) s {
          def to_ast
            if d.respond_to?(:items)
              n :toShiftEnPort_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }
            else
              n :toShiftEnPort_def, name.to_ast
            end
          end
        }
      end

      rule toShiftEnPort_items
        attribute_def /
        toShiftEnPort_source
      end

      rule toShiftEnPort_source
        'Source' S signal:concat_shiftEn_signal s ';' s {
          def to_ast
            n :source, signal.to_ast
          end
        }
      end

      rule toCaptureEnPort_def
        'ToCaptureEnPort' S name:toCaptureEnPort_name s d:(';' / ('{' s items:toCaptureEnPort_items* s '}')) s {
          def to_ast
            if d.respond_to?(:items)
              n :toCaptureEnPort_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }
            else
              n :toCaptureEnPort_def, name.to_ast
            end
          end
        }
      end

      rule toCaptureEnPort_items
        attribute_def /
        toCaptureEnPort_source
      end

      rule toCaptureEnPort_source
        'Source' S signal:captureEn_signal s ';' s {
          def to_ast
            n :source, signal.to_ast
          end
        }
      end

      rule toUpdateEnPort_def
        'ToUpdateEnPort' S name:toUpdateEnPort_name s d:(';' / ('{' s items:toUpdateEnPort_items* s '}')) s {
          def to_ast
            if d.respond_to?(:items)
              n :toUpdateEnPort_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }
            else
              n :toUpdateEnPort_def, name.to_ast
            end
          end
        }
      end 

      rule toUpdateEnPort_items
        attribute_def / toUpdateEnPort_source
      end

      rule toUpdateEnPort_source
        'Source' S signal:updateEn_signal s ';' s {
          def to_ast
            n :source, signal.to_ast
          end
        }
      end

      rule selectPort_def
        'SelectPort' S name:selectPort_name s d:(';' / ('{' s attrs:attribute_def* s '}')) s {
          def to_ast
            if d.respond_to?(:attrs)
              n :selectPort_def, name.to_ast, *d.attrs.elements.map{ |e| e.to_ast }
            else
              n :selectPort_def, name.to_ast
            end
          end
        }
      end

      rule toSelectPort_def
        'ToSelectPort' S name:toSelectPort_name s d:(';' / ('{' s items:toSelectPort_item+ s '}')) s {
          def to_ast
            if d.respond_to?(:items)
              n :toSelectPort_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }
            else
              n :toSelectPort_def, name.to_ast
            end
          end
        }
      end

      rule toSelectPort_item
        attribute_def / toSelectPort_source
      end

      rule toSelectPort_source
        'Source' S signal:concat_data_signal s ';' s {
          def to_ast
            n :source, signal.to_ast
          end
        }
      end

      rule resetPort_def
        'ResetPort' S name:resetPort_name s d:(';' / ('{' s items:resetPort_item* s '}')) s {
          def to_ast
            if d.respond_to?(:items)
              n :resetPort_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }
            else
              n :resetPort_def, name.to_ast
            end
          end
        }
      end

      rule resetPort_item
        attribute_def /
        resetPort_polarity
      end

      rule resetPort_polarity
        'ActivePolarity' S val:('0' / '1') s ';' s {
          def to_ast
            n :resetPort_polarity, val.text_value.to_i
          end
        }
      end

      rule toResetPort_def
        'ToResetPort' S name:toResetPort_name s d:(';' / ('{' s items:toResetPort_item+ s '}')) s {
          def to_ast
            if d.respond_to?(:items)
              n :toResetPort_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }
            else
              n :toResetPort_def, name.to_ast
            end
          end
        }
      end

      rule toResetPort_item
        attribute_def /
        toResetPort_source /
        toResetPort_polarity
      end

      rule toResetPort_source
        'Source' S signal:concat_reset_signal s ';' s {
          def to_ast
            n :source, signal.to_ast
          end
        }
      end

      rule toResetPort_polarity
        'ActivePolarity' S ('0' / '1') s ';' s {
          def to_ast
            n :resetPort_polarity, val.text_value.to_i
          end
        }
      end

      rule tmsPort_def
        'TMSPort' S name:tmsPort_name  s d:(';' / ('{' s attrs:attribute_def* s '}')) s {
          def to_ast
            if d.respond_to?(:attrs)
              n :tmsPort_name, name.to_ast, *d.attrs.elements.map{ |e| e.to_ast }
            else
              n :tmsPort_name, name.to_ast
            end
          end
        }
      end

      rule toTmsPort_def
        'ToTMSPort' S name:toTmsPort_name s d:(';' / ('{' s items:toTmsPort_item* s '}')) s {
          def to_ast
            if d.respond_to?(:items)
              n :toTmsPort_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }
            else
              n :toTmsPort_def, name.to_ast
            end
          end
        }
      end

      rule toTmsPort_item
        attribute_def /
        toTmsPort_source
      end

      rule toTmsPort_source
        'Source' S signal:concat_tms_signal s ';' s {
          def to_ast
            n :source, signal.to_ast
          end
        }
      end

      rule toIRSelectPort_def
        'ToIRSelectPort' S name:toIRSelectPort_name s d:(';' / ('{' s attrs:attribute_def* s '}')) s {
          def to_ast
            if d.respond_to?(:attrs)
              n :toIRSelectPort_def, name.to_ast, *d.attrs.elements.map{ |e| e.to_ast }
            else
              n :toIRSelectPort_def, name.to_ast
            end
          end
        }
      end

      rule tckPort_def
        'TCKPort' S name:tckPort_name s d:(';' / ('{' s attrs:attribute_def* s '}')) s {
          def to_ast
            if d.respond_to?(:attrs)
              n :tckPort_def, name.to_ast, *d.attrs.elements.map{ |e| e.to_ast }
            else
              n :tckPort_def, name.to_ast
            end
          end
        }
      end

      rule toTckPort_def
        'ToTCKPort' S name:toTckPort_name s d:(';' / ('{' s attrs:attribute_def* s '}')) s {
          def to_ast
            if d.respond_to?(:attrs)
              n :toTckPort_def, name.to_ast, *d.attrs.elements.map{ |e| e.to_ast }
            else
              n :toTckPort_def, name.to_ast
            end
          end
        }
      end

      rule clockPort_def
        'ClockPort' S name:clockPort_name s d:(';' / ('{' s items:clockPort_item* s '}')) s {
          def to_ast
            if d.respond_to?(:items)
              n :clockPort_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }
            else
              n :clockPort_def, name.to_ast
            end
          end
        }
      end

      rule clockPort_item
        attribute_def /
        clockPort_diffPort
      end

      rule clockPort_diffPort
        'DifferentialInvOf' S signal:concat_clock_signal s ';' s {
          def to_ast
            n :clockPort_diffPort, signal.to_ast
          end
        }
      end

      rule toClockPort_def
        'ToClockPort' S name:toClockPort_name s d:(';' / ('{' s items:toClockPort_item+ s '}')) s {
          def to_ast
            if d.respond_to?(:items)
              n :toClockPort_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }
            else
              n :toClockPort_def, name.to_ast
            end
          end
        }
      end

      rule toClockPort_item
        attribute_def /
        toClockPort_source /
        freqMultiplier_def /
        freqDivider_def /
        differentialInvOf_def /
        period_def
      end

      rule toClockPort_source
        'Source' S signal:concat_clock_signal s ';' s {
          def to_ast
            n :source, signal.to_ast
          end
        }
      end

      rule freqMultiplier_def
        'FreqMultiplier' S val:POS_INT s ';' s {
          def to_ast
            n :freqMultiplier_def, val.to_ast
          end
        }
      end

      rule freqDivider_def
        'FreqDivider' S val:POS_INT s ';' s {
          def to_ast
            n :freqDivider_def, val.to_ast
          end
        }
      end

      rule differentialInvOf_def
        'DifferentialInvOf' S val:concat_clock_signal s ';' s {
          def to_ast
            n :differentialInvOf_def, val.to_ast
          end
        }
      end

      rule period_def
        'Period' S val:POS_INT s unit:('s' / 'ms' / 'us' / 'ns' / 'ps' / 'fs' / 'as')? s ';' s {
          def to_ast
            n :period_def, "#{v.to_ast}#{unit}"
          end
        }
      end

      rule trstPort_def
        'TRSTPort' S name:trstPort_name s d:(';' / ('{' s attrs:attribute_def* s '}')) s {
          def to_ast
            if d.respond_to?(:items)
              n :trstPort_def, name.to_ast, *d.attrs.elements.map{ |e| e.to_ast }
            else
              n :trstPort_def, name.to_ast
            end
          end
        }
      end

      rule toTrstPort_def
        'ToTRSTPort' S name:toTrstPort_name s d:(';' / ('{' s items:toTrstPort_item+ s '}')) s {
          def to_ast
            if d.respond_to?(:items)
              n :toTrstPort_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }
            else
              n :toTrstPort_def, name.to_ast
            end
          end
        }
      end

      rule toTrstPort_item
        attribute_def /
        toTrstPort_source
      end

      rule toTrstPort_source
        'Source' S signal:concat_trst_signal s ';' s {
          def to_ast
            n :source, signal.to_ast
          end
        }
      end

      rule addressPort_def
        'AddressPort' S name:addressPort_name s d:(';' / ('{' s attrs:attribute_def* s '}')) s {
          def to_ast
            if d.respond_to?(:attrs)
              n :addressPort_def, name.to_ast, *d.attrs.elements.map{ |e| e.to_ast }
            else
              n :addressPort_def, name.to_ast
            end
          end
        }
      end

      rule writeEnPort_def
        'WriteEnPort' S name:writeEnPort_name s d:(';' / ('{' s attrs:attribute_def* s '}')) s {
          def to_ast
            if d.respond_to?(:attrs)
              n :writeEnPort_def, name.to_ast, *d.attrs.elements.map{ |e| e.to_ast }
            else
              n :writeEnPort_def, name.to_ast
            end
          end
        }
      end

      rule readEnPort_def
        'ReadEnPort' S name:readEnPort_name s d:(';' / ('{' s attrs:attribute_def* s '}')) s {
          def to_ast
            if d.respond_to?(:attrs)
              n :readEnPort_def, name.to_ast, *d.attrs.elements.map{ |e| e.to_ast }
            else
              n :readEnPort_def, name.to_ast
            end
          end
        }
      end

      # Instance WI1 Of NS::WrappedInstr {
      #                 InputPort SI = SI;
      #                 InputPort SEL = SEL1;
      # }
      rule instance_def
        'Instance' S name:instance_name S 'Of' S mod:((namespace_name? '::')? module_name) s d:(';' / ('{' s items:instance_item* s '}')) s {
          def to_ast
            if d.respond_to?(:items)
              n :instance_def, name.to_ast, n(:module_name, mod.text_value), *d.items.elements.map{ |e| e.to_ast }
            else
              n :instance_def, name.to_ast, n(:module_name, mod.text_value)
            end
          end
        }
      end

      rule instance_item
        inputPort_connection /
        allowBroadcast_def /
        attribute_def /
        parameter_override /
        instance_addressValue
      end

      rule inputPort_connection
        'InputPort' S name:inputPort_name s '=' s source:inputPort_source s ';' s {
          def to_ast
            n :inputPort_connection, name.to_ast, source.to_ast
          end
        }
      end

      rule allowBroadcast_def
        'AllowBroadcastOnScanInterface' S name:scanInterface_name s ';' s {
          def to_ast
            n :allowBroadcast_def, name.to_ast
          end
        }
      end

      rule inputPort_source
        concat_reset_signal /
        concat_scan_signal /
        concat_data_signal /
        concat_clock_signal /
        concat_tck_signal /
        concat_shiftEn_signal /
        concat_captureEn_signal /
        concat_updateEn_signal /
        concat_tms_signal /
        concat_trst_signal
      end

      rule instance_addressValue
        'AddressValue' S val:number s ';' s {
          def to_ast
            n :instance_addressValue, val.to_ast
          end
        }
      end

      rule scanRegister_def
        'ScanRegister' S name:scanRegister_name s d:(';' / ('{' s items:scanRegister_item* s '}')) s {
          def to_ast
            if d.respond_to?(:items)
              n :scanRegister_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }, input: input, interval: interval
            else
              n :scanRegister_def, name.to_ast, input: input, interval: interval
            end
          end
        }
      end

      rule scanRegister_item
        attribute_def /
        scanRegister_scanInSource /
        scanRegister_defaultLoadValue /
        scanRegister_captureSource /
        scanRegister_resetValue /
        scanRegister_refEnum
      end

      rule scanRegister_scanInSource
        'ScanInSource' S signal:scan_signal s ';' s {
          def to_ast
            n :scanRegister_scanInSource, signal.to_ast
          end
        }
      end

      rule scanRegister_defaultLoadValue
        'DefaultLoadValue' S val:(concat_number / enum_symbol) s ';' s {
          def to_ast
            n :scanRegister_defaultLoadValue, val.to_ast
          end
        }
      end

      rule scanRegister_captureSource
        'CaptureSource' S source:(concat_data_signal / enum_symbol) s ';' s {
          def to_ast
            n :scanRegister_captureSource, source.to_ast
          end
        }
      end

      rule scanRegister_resetValue
        'ResetValue' S val:(concat_number / enum_symbol) s ';' s {
          def to_ast
            n :scanRegister_resetValue, val.to_ast
          end
        }
      end

      rule scanRegister_refEnum
        'RefEnum' S name:enum_name s ';' s {
          def to_ast
            n :refEnum, name.to_ast
          end
        }
      end

      rule dataRegister_def
        'DataRegister' S name:dataRegister_name s d:(';' / ('{' s items:dataRegister_item+ s '}')) s {
          def to_ast
            if d.respond_to?(:items)
              n :dataRegister_def, name.to_ast, *d.items.elements.map{ |e| e.to_ast }
            else
              n :dataRegister_def, name.to_ast
            end
          end
        }
      end

      rule dataRegister_item
        dataRegister_type /
        dataRegister_common
      end

      rule dataRegister_type
        dataRegister_selectable /
        dataRegister_addressable /
        dataRegister_readCallBack /
        dataRegister_writeCallBack
      end

      rule dataRegister_common
        dataRegister_resetValue /
        dataRegister_defaultLoadValue /
        dataRegister_refEnum /
        attribute_def
      end

      rule dataRegister_resetValue
        'ResetValue' S val:(concat_number / enum_symbol) s ';' s {
          def to_ast
            n :dataRegister_resetValue, val.to_ast
          end
        }
      end

      rule dataRegister_defaultLoadValue
        'DefaultLoadValue' S val:(concat_number / enum_symbol) s ';' s {
          def to_ast
            n :dataRegister_defaultLoadValue, val.to_ast
          end
        }
      end

      rule dataRegister_refEnum
        'RefEnum' S name:enum_name s ';' s {
          def to_ast
            n :refEnum, name.to_ast
          end
        }
      end

      rule dataRegister_selectable
        dataRegister_writeEnSource /
        dataRegister_writeDataSource
      end

      rule dataRegister_writeEnSource
        'WriteEnSource' S signal:data_signal s ';' s {
          def to_ast
            n :dataRegister_writeEnSource, signal.to_ast
          end
        }
      end

      rule dataRegister_writeDataSource
        'WriteDataSource' S signal:concat_data_signal s ';' s {
          def to_ast
            n :dataRegister_writeDataSource, signal.to_ast
          end
        }
      end

      rule dataRegister_addressValue
        'AddressValue' S val:number s ';' s {
          def to_ast
            n :dataRegister_addressValue, val.to_ast
          end
        }
      end

      rule dataRegister_readCallBack
        dataRegister_readCallBack_proc /
        dataRegister_readDataSource
      end

      rule dataRegister_readCallBack_proc
        'ReadCallBack' S namespace:iProc_namespace S name:iProc_name s args:iProc_args* s ';' s {
          def to_ast
            if respond_to?(:args)
              n :dataRegister_readCallBack_proc, namespace.to_ast, name.to_ast, *args.elements.map{ |e| e.to_ast }
            else
              n :dataRegister_readCallBack_proc, namespace.to_ast, name.to_ast
            end
          end
        }
      end

      rule dataRegister_readDataSource
        'ReadDataSource' S signal:concat_data_signal s ';' s {
          def to_ast
            n :dataRegister_readDataSource, signal.to_ast
          end
        }
      end

      rule dataRegister_writeCallBack
        'WriteCallBack' S namespace:iProc_namespace S name:iProc_name s args:iProc_args* s ';' s {
          def to_ast
            if respond_to?(:args)
              n :dataRegister_writeCallBack, namespace.to_ast, name.to_ast, *args.elements.map{ |e| e.to_ast }
            else
              n :dataRegister_writeCallBack, namespace.to_ast, name.to_ast
            end
          end
        }
      end

      rule iProc_namespace
        (namespace_name? '::')? ref_module_name ( '::' sub_namespace )? s {
          def to_ast
            n :iProc_namespace, text_value
          end
        }
      end

      rule iProc_name
        SCALAR_ID / parameter_ref
      end

      rule iProc_args
        '<D>' /
        '<R>' /
        number /
        STRING /
        parameter_ref
      end

      rule sub_namespace
        SCALAR_ID /
        parameter_ref
      end

      rule ref_module_name
        SCALAR_ID /
        parameter_ref
      end

      rule logicSignal_def
        'LogicSignal' S name:logicSignal_name s '{' s expr:logic_expr s ';' s '}' s {
          def to_ast
            n :logicSignal_def, name.to_ast, expr.to_ast
          end
        }
      end

      rule scanMux_def
        'ScanMux' S name:scanMux_name S 'SelectedBy' S select:scanMux_select s '{' s selections:scanMux_selection+ s '}' s {
          def to_ast
            n :scanMux_def, name.to_ast, select.to_ast, *selections.elements.map{ |e| e.to_ast }
          end
        }
      end

      rule scanMux_selection
        val:(concat_number_list ':' concat_scan_signal) s ';' s {
          def to_ast
            n :scanMux_selection, val.text_value
          end
        }
      end

      rule dataMux_def
        'DataMux' S name:dataMux_name S 'SelectedBy' S select:dataMux_select s '{' s selections:dataMux_selection+ s '}' s {
          def to_ast
            n :dataMux_def, name.to_ast, select.to_ast, *selections.elements.map{ |e| e.to_ast }
          end
        }
      end

      rule dataMux_selection
        val:(concat_number_list ':' concat_data_signal) s ';' s {
          def to_ast
            n :dataMux_selection, val.text_value
          end
        }
      end

      rule clockMux_def
        'ClockMux' S name:clockMux_name S 'SelectedBy' S select:clockMux_select s '{' s selections:clockMux_selection+ s '}' s {
          def to_ast
            n :clockMux_def, name.to_ast, select.to_ast, *selections.elements.map{ |e| e.to_ast }
          end
        }
      end

      rule clockMux_selection
        val:(concat_number_list ':' concat_clock_signal) s ';' s {
          def to_ast
            n :clockMux_selection, val.text_value
          end
        }
      end

      rule oneHotScanGroup_def
        'OneHotScanGroup' S name:oneHotScanGroup_name s '{' s items:oneHotScanGroup_item+ s '}' s {
          def to_ast
            n :oneHotScanGroup_def, name.to_ast, *items.elements.map{ |e| e.to_ast }
          end
        }
      end

      rule oneHotScanGroup_item
        'Port' S signal:concat_scan_signal s ';' s {
          def to_ast
            n :oneHotScanGroup_item, signal.to_ast
          end
        }
      end

      rule oneHotDataGroup_def
        'OneHotDataGroup' S name:oneHotDataGroup_name s '{' s items:oneHotDataGroup_item+ s '}' s {
          def to_ast
            n :oneHotDataGroup_def, name.to_ast, *items.elements.map{ |e| e.to_ast }
          end
        }
      end

      rule oneHotDataGroup_item
        instance_def /
        dataRegister_def /
        oneHotDataGroup_portSource
      end

      rule oneHotDataGroup_portSource
        'Port' S signal:concat_data_signal s ';' s {
          def to_ast
            n :oneHotDataGroup_portSource, signal.to_ast
          end
        }
      end

      rule scanInterface_def
        'ScanInterface' S name:scanInterface_name s '{' s items:scanInterface_item+ s '}' s {
          def to_ast
            n :scanInterface_def, name.to_ast, *items.elements.map{ |e| e.to_ast }
          end
        }
      end

      rule scanInterface_item
        attribute_def /
        scanInterfacePort_def /
        defaultLoad_def /
        scanInterfaceChain_def
      end

      rule scanInterfacePort_def
        'Port' S signal:reg_port_signal_id s ';' s {
          def to_ast
            n :scanInterfacePort_def, signal.to_ast
          end
        }
      end

      rule scanInterfaceChain_def
        'Chain' S name:scanInterfaceChain_name s '{' s items:scanInterfaceChain_item+ s '}' s {
          def to_ast
            n :scanInterfaceChain_def, name.to_ast, *items.elements.map{ |e| e.to_ast }
          end
        }
      end

      rule scanInterfaceChain_item
        attribute_def /
        scanInterfacePort_def /
        defaultLoad_def
      end

      rule defaultLoad_def
        'DefaultLoadValue' S val:concat_number s ';' s {
          def to_ast
            n :defaultLoad_def, val.to_ast
          end
        }
      end

      rule accessLink_def
        accessLink1149_def /
        AccessLinkGeneric_def
      end

      rule AccessLinkGeneric_def
        'AccessLink' S v1:SCALAR_ID S 'Of' S v2:SCALAR_ID s {
          def to_ast
            n :AccessLinkGeneric_def, v1.to_ast, v2.to_ast
          end
        }
      end

      #rule AccessLinkGeneric_block
      #  '{' s (AccessLinkGeneric_block / AccessLinkGeneric_text / S / STRING)* s '}' s {
      #    def to_ast
      #      fail "AccessLinkGeneric_block not implemented yet!"
      #    end
      #  }
      #end

      #rule AccessLinkGeneric_text
      #  #[^{}"\t\n\r ]+
      #end

      rule accessLink1149_def
        'AccessLink' S link:accessLink_name S 'Of' S type:('STD_1149_1_2001' / 'STD_1149_1_2013') s '{' s 'BSDLEntity' S bname:bsdlEntity_name s ';' s refs:bsdl_instr_ref+  s '}' s {
          def to_ast
            n :accessLink1149_def, ling.to_ast, type.text_value, bname.to_ast, *refs.elements.map{ |e| e.to_ast }
          end
        }
      end

      rule bsdl_instr_ref
        name:bsdl_instr_name s '{' s items:bsdl_instr_selected_item+ s '}' s {
          def to_ast
            n :bsdl_instr_ref, name.to_ast, *items.elements.map{ |e| e.to_ast }
          end
        }
      end

      rule bsdl_instr_selected_item
        d:(('ScanInterface' s '{' s names:(accessLink1149_ScanInterface_name ';')+ s '}')  / ('ActiveSignals' s '{' s names:(accessLink1149_ActiveSignal_name ';')+ s '}')) s {
          def to_ast
            n :bsdl_instr_selected_item, *d.names.elements.map{ |e| e.to_ast }
          end
        }
      end

      rule accessLink1149_ScanInterface_name
        val:(instance_name ('.' scanInterface_name)?) s {
          def to_ast
            n :accessLink1149_ScanInterface_name, val.text_value
          end
        }
      end

      rule alias_def
        'Alias' S name:alias_name s '=' s signal:concat_hier_data_signal s d:(';' / ('{' s items:alias_item+ s '}' s )) s {
          def to_ast
            if d.respond_to?(:items)
              n :alias_def, name.to_ast, signal.to_ast, *d.items.elements.map{ |e| e.to_ast }
            else
              n :alias_def, name.to_ast, signal.to_ast
            end
          end
        }
      end

      rule alias_item
        attribute_def /
        access_together /
        alias_iApplyEndState /
        alias_refEnum
      end

      rule alias_iApplyEndState
        'iApplyEndState' S num:concat_number s ';' s {
          def to_ast
            n :alias_iApplyEndState, num.to_ast
          end
        }
      end

      rule alias_refEnum
        'RefEnum' S name:enum_name s ';' s {
          def to_ast
            n :refEnum, name.to_ast
          end
        }
      end

      rule access_together
        'AccessTogether' s ';' s {
          def to_ast
            n0 :access_together
          end
        }
      end

      rule concat_hier_data_signal
        s1:(inverted_hier_data_signal / hier_data_signal) s2:(s ',' s signal:(inverted_hier_data_signal / hier_data_signal))* {
          def to_ast
            if s2.empty?
              s1.to_ast
            else
              n :concat, s1.to_ast, *s2.elements.map{ |e| e.signal.to_ast }
            end
          end
        }
      end

      rule hier_data_signal
        instances:(name:instance_name '.')* signal:reg_port_signal_id {
          def to_ast
            if !instances.empty?
              n :hier_data_signal, *instances.elements.map{ |e| e.name.to_ast }, signal.to_ast
            else
              signal.to_ast
            end
          end
        }
      end

      rule inverted_hier_data_signal
        '~' instances:(name:instance_name '.')* signal:reg_port_signal_id {
          def to_ast
            if !instances.empty?
              n :inverted_hier_data_signal, *instances.elements.map{ |e| e.name.to_ast }, signal.to_ast
            else
              n :inverted_signal, signal.to_ast
            end
          end
        }
      end

      rule enum_def
        'Enum' S name:enum_name s '{' s items:enum_item+ s '}' s {
          def to_ast
            n :enum_def, name.to_ast, *items.elements.map{ |e| e.to_ast }
          end
        }
      end

      rule enum_item
        sym:enum_symbol s '=' s val:enum_value s ';' s {
          def to_ast
            n :enum_item, sym.to_ast, val.to_ast
          end
        }
      end

      rule parameter_def
        'Parameter' S name:parameter_name s '=' s val:parameter_value s ';' s {
          def to_ast
            n :parameter_def, name.to_ast, val.to_ast
          end
        }
      end

      rule localParameter_def
        'LocalParameter' S name:parameter_name s '=' s val:parameter_value s ';' s {
          def to_ast
            n :localParameter_def, name.to_ast, val.to_ast
          end
        }
      end

      rule parameter_value
        concat_string /
        concat_number
      end

      rule concat_string
        (STRING / parameter_ref) (',' s (STRING / parameter_ref))* s {
          def to_ast
            n :concat_string, text_value
          end
        }
      end

      rule attribute_def
        'Attribute' S name:attribute_name s ('=' s val:attribute_value s)? ';' s {
          def to_ast
            n :attribute_def, name.to_ast, val.to_ast
          end
        }
      end

      rule attribute_value
        concat_string /
        concat_number
      end

      rule STRING
        '"' (!('"' / '\\') / '\\\\' / '\\"')* '"'
      end

      ####################################################
      # TERMINAL NODES
      ####################################################

      rule enum_name
        SCALAR_ID
      end

      rule enum_symbol
        SCALAR_ID
      end

      rule parameter_name
        SCALAR_ID
      end

      rule attribute_name
        SCALAR_ID
      end

      rule enum_value
        concat_number
      end

      rule alias_name
        reg_port_signal_id
      end

      rule accessLink1149_ActiveSignal_name
        reg_port_signal_id
      end

      rule accessLink_name
        SCALAR_ID
      end

      rule bsdlEntity_name
        SCALAR_ID
      end

      rule bsdl_instr_name
        SCALAR_ID
      end

      rule accessLink_genericID
        SCALAR_ID
      end

      rule scanInterfaceChain_name
        SCALAR_ID
      end

      rule scanInterface_name
        SCALAR_ID
      end

      rule oneHotDataGroup_name
        reg_port_signal_id
      end

      rule oneHotScanGroup_name
        reg_port_signal_id
      end

      rule clockMux_name
        reg_port_signal_id
      end

      rule clockMux_select
        concat_data_signal
      end

      rule dataMux_name
        reg_port_signal_id
      end

      rule dataMux_select
        concat_data_signal
      end

      rule scanMux_name
        reg_port_signal_id
      end

      rule scanMux_select
        concat_data_signal
      end

      rule logicSignal_name
        reg_port_signal_id
      end

      rule dataRegister_addressable
        dataRegister_addressValue
      end

      rule dataRegister_name
        register_name
      end

      rule scanRegister_name
        register_name
      end

      rule parameter_override
        parameter_def
      end

      rule inputPort_name
        port_name
      end

      rule readEnPort_name
        port_name
      end

      rule writeEnPort_name
        port_name
      end

      rule addressPort_name
        port_name
      end

      rule toTrstPort_name
        port_name
      end

      rule trstPort_name
        port_name
      end

      rule toClockPort_name
        port_name
      end

      rule clockPort_name
        port_name
      end

      rule toTckPort_name
        port_name
      end

      rule tckPort_name
        port_name
      end

      rule toIRSelectPort_name
        port_name
      end

      rule toTmsPort_name
        port_name
      end

      rule tmsPort_name
        port_name
      end

      rule toResetPort_name
        port_name
      end

      rule resetPort_name
        port_name
      end

      rule toSelectPort_name
        port_name
      end

      rule selectPort_name
        port_name
      end

      rule toUpdateEnPort_name
        port_name
      end

      rule toCaptureEnPort_name
        port_name
      end
      
      rule toShiftEnPort_name
        port_name
      end

      rule dataOutPort_name
        port_name
      end

      rule dataInPort_name
        port_name
      end

      rule updateEnPort_name
        port_name
      end

      rule captureEnPort_name
        port_name
      end

      rule shiftEnPort_name
        port_name
      end

      rule scanInPort_name
        port_name
      end

      rule scanOutPort_name
        port_name
      end

      rule hier_port
        ins:(name:instance_name ".")+ port:port_name s {
          def to_ast
            n :hier_port, *ins.elements.map{ |e| e.name.to_ast }, port.to_ast
          end
        }
      end

      rule port_name
        vector_id / SCALAR_ID
      end

      rule register_name
        vector_id / SCALAR_ID
      end

      rule instance_name
        SCALAR_ID
      end

      rule namespace_name
        SCALAR_ID
      end

      rule module_name
        SCALAR_ID
      end

      rule reg_port_signal_id
        vector_id / SCALAR_ID
      end

      rule signal
        hier_port / reg_port_signal_id / number
      end

      rule reset_signal
        invert:"~"? val:signal { 
          def to_ast
            if !invert.empty?
              n :reset_signal, n0(:invert), val.to_ast
            else
              n :reset_signal, val.to_ast
            end
          end
        }
      end

      rule scan_signal
        invert:"~"? val:signal { 
          def to_ast
            if !invert.empty?
              n :scan_signal, n0(:invert), val.to_ast
            else
              n :scan_signal, val.to_ast
            end
          end
        }
      end
      
      rule data_signal
        invert:"~"? val:signal { 
          def to_ast
            if !invert.empty?
              n :data_signal, n0(:invert), val.to_ast
            else
              n :data_signal, val.to_ast
            end
          end
        }
      end

      rule clock_signal
        invert:"~"? val:signal { 
          def to_ast
            if !invert.empty?
              n :clock_signal, n0(:invert), val.to_ast
            else
              n :clock_signal, val.to_ast
            end
          end
        }
      end

      rule tck_signal
        signal
      end

      rule tms_signal
        signal
      end

      rule trst_signal
        signal
      end

      rule shiftEn_signal
        signal
      end

      rule captureEn_signal
        signal
      end

      rule updateEn_signal
        signal
      end

      rule concat_reset_signal
        s1:(reset_signal / data_signal) s2:(s "," s signal:(reset_signal / data_signal))* { 
          def to_ast
            if s2.empty?
              s1.to_ast
            else
              n :concat, s1.to_ast, *s2.elements.map{ |e| e.signal.to_ast }
            end
          end
        }
      end

      rule concat_scan_signal
        s1:(scan_signal / data_signal) s2:(s "," s signal:(scan_signal / data_signal))* { 
          def to_ast
            if s2.empty?
              s1.to_ast
            else
              n :concat, s1.to_ast, *s2.elements.map{ |e| e.signal.to_ast }
            end
          end
        }
      end

      rule concat_data_signal
        s1:(data_signal) s2:(s "," s signal:data_signal)* { 
          def to_ast
            if s2.empty?
              s1.to_ast
            else
              n :concat, s1.to_ast, *s2.elements.map{ |e| e.signal.to_ast }
            end
          end
        }
      end

      rule concat_clock_signal
        s1:(clock_signal / data_signal) s2:(s "," s signal:(clock_signal / data_signal))* { 
          def to_ast
            if s2.empty?
              s1.to_ast
            else
              n :concat, s1.to_ast, *s2.elements.map{ |e| e.signal.to_ast }
            end
          end
        }
      end

      rule concat_tck_signal
        s1:(tck_signal / data_signal) s2:(s "," s signal:(tck_signal / data_signal))* { 
          def to_ast
            if s2.empty?
              s1.to_ast
            else
              n :concat, s1.to_ast, *s2.elements.map{ |e| e.signal.to_ast }
            end
          end
        }
      end

      rule concat_shiftEn_signal
        s1:(shiftEn_signal / data_signal) s2:(s "," s signal:(shiftEn_signal / data_signal))* { 
          def to_ast
            if s2.empty?
              s1.to_ast
            else
              n :concat, s1.to_ast, *s2.elements.map{ |e| e.signal.to_ast }
            end
          end
        }
      end

      rule concat_captureEn_signal
        s1:(captureEn_signal / data_signal) s2:(s "," s signal:(captureEn_signal / data_signal))* {
          def to_ast
            if s2.empty?
              s1.to_ast
            else
              n :concat, s1.to_ast, *s2.elements.map{ |e| e.signal.to_ast }
            end
          end
        }
      end

      rule concat_tms_signal
        s1:(tms_signal / data_signal) s2:("," signal:(tms_signal / data_signal))* { 
          def to_ast
            if s2.empty?
              s1.to_ast
            else
              n :concat, s1.to_ast, *s2.elements.map{ |e| e.signal.to_ast }
            end
          end
        }
      end

      rule concat_trst_signal
        s1:(trst_signal / data_signal) s2:("," signal:(trst_signal / data_signal))* { 
          def to_ast
            if s2.empty?
              s1.to_ast
            else
              n :concat, s1.to_ast, *s2.elements.map{ |e| e.signal.to_ast }
            end
          end
        }
      end

      ####################################################
      # VALUE FORMATS
      ####################################################

      rule SCALAR_ID
        [a-zA-Z] ([a-zA-Z_] / DEC_DIGIT)* {
          def to_ast
            n :SCALAR_ID, text_value
          end
        }
      end

      rule POS_INT
        DEC_DIGIT ('_' / DEC_DIGIT)* {
          def to_ast
            n :POS_INT, text_value.sub("_", "").to_i
          end
        }
      end

      rule size
        POS_INT / parameter_ref
      end

      rule UNKNOWN_DIGIT
        'X' / 'x' {
          def to_ast
            n0 :UNKNOWN_DIGIT
          end
        }
      end

      rule DEC_DIGIT
        [0-9]
      end

      rule BIN_DIGIT
        [0-1] / UNKNOWN_DIGIT
      end

      rule HEX_DIGIT
        [0-9a-fA-F] / UNKNOWN_DIGIT
      end

      rule DEC_BASE
        "'" ('d' / 'D') (" " / "\t")*
      end

      rule BIN_BASE
        "'" ('b' / 'B') (" " / "\t")*
      end

      rule HEX_BASE
        "'" ('h' / 'H') (" " / "\t")*
      end

      rule UNSIZED_DEC_NUMBER
        DEC_BASE val:POS_INT {
          def to_ast
            val.to_ast
          end
        }
      end

      rule UNSIZED_BIN_NUMBER
        BIN_BASE val:(BIN_DIGIT ("_" / BIN_DIGIT)*) {
          def to_ast
            n :UNSIZED_BIN_NUMBER, val.text_value.sub("_", "")
          end
        }
      end

      rule UNSIZED_HEX_NUMBER
        HEX_BASE val:(HEX_DIGIT ("_" / HEX_DIGIT)*) {
          def to_ast
            n :UNSIZED_HEX_NUMBER, val.text_value.sub("_", "").upcase
          end
        }
      end

      rule sized_dec_number
        v1:size v2:UNSIZED_DEC_NUMBER {
          def to_ast
            n :sized_dec_number, v1.to_ast, v2.to_ast
          end
        }
      end

      rule sized_bin_number
        v1:size v2:UNSIZED_BIN_NUMBER {
          def to_ast
            n :sized_bin_number, v1.to_ast, v2.to_ast
          end
        }
      end

      rule sized_hex_number
        v1:size v2:UNSIZED_HEX_NUMBER {
          def to_ast
            n :sized_hex_number, v1.to_ast, v2.to_ast
          end
        }
      end

      rule vector_id
        name:SCALAR_ID "[" val:(range / index) "]" {
          def to_ast
            n :vector_id, name.to_ast, val.to_ast
          end
        }
      end

      rule index
        integer_expr
      end

      rule range
        start:index ":" stop:index {
          def to_ast
            n :range, start.to_ast, stop.to_ast
          end
        }
      end

      rule number
        sized_number / unsized_number / integer_expr
      end

      rule integer_expr
        expr:integer_expr_lvl1 {
          def to_ast
            expr.to_ast
          end
        }
      end

      rule integer_expr_lvl1
        left:integer_expr_lvl2 right:(op:("+" / "-") expr:integer_expr_lvl1)? {
          def to_ast
            if right.respond_to?(:op)
              if right.op.text_value == "+"
                n :add, left.to_ast, right.expr.to_ast
              else
                n :subtract, left.to_ast, right.expr.to_ast
              end
            else
              left.to_ast
            end
          end
        }
      end

      rule integer_expr_lvl2
        left:integer_expr_arg right:(op:("*" / "/" / "%") expr:integer_expr_lvl2)? {
          def to_ast
            if right.respond_to?(:op)
              if right.op.text_value == "*"
                n :multiply, left.to_ast, right.expr.to_ast
              elsif right.op.text_value == "/"
                n :divide, left.to_ast, right.expr.to_ast
              else
                n :modulus, left.to_ast, right.expr.to_ast
              end
            else
              left.to_ast
            end
          end
        }
      end

      rule integer_expr_paren
        "(" expr:integer_expr ")" {
          def to_ast
            expr.to_ast
          end
        }
      end

      rule integer_expr_arg
        integer_expr_paren / POS_INT / parameter_ref
      end

      rule logic_expr
        logic_expr_lvl1
      end

      rule logic_expr_lvl1
        logic_expr_lvl2 (('&&' / '||') logic_expr_lvl1)?
      end

      rule logic_expr_lvl2
        logic_expr_lvl3 (('&' / '|' / '^') logic_expr_lvl2)? / (('&' / '|' / '^') logic_expr_lvl2)
      end

      rule logic_expr_lvl3
        logic_expr_lvl4 (('==' / '!=') logic_expr_num_arg)?
      end

      rule logic_expr_lvl4
        logic_expr_arg (',' logic_expr_lvl4 )?
      end

      rule logic_unary_expr
        ('~' / '!') logic_expr_arg
      end

      rule logic_expr_paren
        '(' s logic_expr s ')'
      end

      rule logic_expr_arg
        logic_expr_paren /
        logic_unary_expr /
        concat_data_signal
      end

      rule logic_expr_num_arg
        concat_number / enum_name / '(' s logic_expr_num_arg s ')' 
      end

      rule parameter_ref
        "$" id:SCALAR_ID {
          def to_ast
            n :parameter_ref, id.to_ast
          end
        }
      end

      rule unsized_number
        UNSIZED_DEC_NUMBER / UNSIZED_BIN_NUMBER / UNSIZED_HEX_NUMBER / POS_INT
      end

      rule sized_number
        sized_dec_number / sized_bin_number / sized_hex_number
      end

      rule concat_number
        invert:"~"? s1:number s2:("," "~"? val:number)* {
          def to_ast
            fail "concat_number invert not handled yet!" unless invert.empty?
            if s2.empty?
              s1.to_ast
            else
              n :concat, s1.to_ast, *s2.elements.map{ |e| e.val.to_ast }
            end
          end
        }
      end

      rule concat_number_list
        concat_number ("|" concat_number)*
      end

      ####################################################
      # HELPERS
      ####################################################

      # Optional space, including new lines and comments
      rule s
        (" " / "\t" / N / sl_comment / ml_comment)*
      end

      # Required space, including new lines and comments
      rule S
        (" " / "\t" / N / sl_comment / ml_comment)+
      end

      # Optional end of line
      rule n
        "\r"? "\n"?
      end

      # Required end of line
      rule N
        "\r"? "\n"
      end
    end
  end
end
